00018                 | 
00018                 | #line 1 "C:/Users/currentc/Dropbox/Projects/src/propeller/libraries/community/p1/All/megunolink_ez/examples/Getting Started/Sinewave/Sinewave.pasm"
00018                 | con
00018                 | 	_clkfreq = 80000000
00018                 | 	_clkmode = 1032
00018                 | '         _clkmode = xtal1 + pll16x                                               'Standard clock mode * crystal frequency = 80 MHz
00018                 | '         _xinfreq = 5_000_000
00018                 | 	_xinfreq = 5000000
00018                 | ' 
00018                 | '         TX = 30
00018                 | 	TX = 30
00018                 | '         RX = 31
00018                 | 	RX = 31
00018                 | '         LED = 16
00018                 | 	LED = 16
00018                 | '         CR = $0A
00018                 | 	CR = 10
00018                 | pub main
00018                 |   coginit(0, @entry, 0)
00018                 | dat
00018 000             | 	org	0
00018 000             | entry
00018 000 F0 AD BD A2 | 	mov	arg01, par wz
0001c 001 07 00 54 5C |  if_ne	jmp	#spininit
00020 002 04 5E BC A0 | 	mov	pc, $+2
00024 003 3E 82 FC 5C | 	call	#LMM_CALL_FROM_COG
00028 004 60 03 00 00 | 	long	@@@_main
0002c 005             | cogexit
0002c 005 01 AC FD 0C | 	cogid	arg01
00030 006 03 AC 7D 0C | 	cogstop	arg01
00034 007             | spininit
00034 007 D6 A0 BD A0 | 	mov	sp, arg01
00038 008 D0 72 BD 08 | 	rdlong	objptr, sp
0003c 009 04 A0 FD 80 | 	add	sp, #4
00040 00a D0 5E BC 08 | 	rdlong	pc, sp
00044 00b D0 9C 3D 08 | 	wrlong	ptr_hubexit_, sp
00048 00c 04 A0 FD 80 | 	add	sp, #4
0004c 00d D0 AC BD 08 | 	rdlong	arg01, sp
00050 00e 04 A0 FD 80 | 	add	sp, #4
00054 00f D0 AE BD 08 | 	rdlong	arg02, sp
00058 010 04 A0 FD 80 | 	add	sp, #4
0005c 011 D0 B0 BD 08 | 	rdlong	arg03, sp
00060 012 04 A0 FD 80 | 	add	sp, #4
00064 013 D0 B2 BD 08 | 	rdlong	arg04, sp
00068 014 0C A0 FD 84 | 	sub	sp, #12
0006c 015 16 00 7C 5C | 	jmp	#LMM_LOOP
00070 016             | LMM_LOOP
00070 016 2F 30 BC 08 |     rdlong LMM_i1, pc
00074 017 04 5E FC 80 |     add    pc, #4
00078 018             | LMM_i1
00078 018 00 00 00 00 |     nop
0007c 019 2F 36 BC 08 |     rdlong LMM_i2, pc
00080 01a 04 5E FC 80 |     add    pc, #4
00084 01b             | LMM_i2
00084 01b 00 00 00 00 |     nop
00088 01c 2F 3C BC 08 |     rdlong LMM_i3, pc
0008c 01d 04 5E FC 80 |     add    pc, #4
00090 01e             | LMM_i3
00090 01e 00 00 00 00 |     nop
00094 01f 2F 42 BC 08 |     rdlong LMM_i4, pc
00098 020 04 5E FC 80 |     add    pc, #4
0009c 021             | LMM_i4
0009c 021 00 00 00 00 |     nop
000a0 022 2F 48 BC 08 |     rdlong LMM_i5, pc
000a4 023 04 5E FC 80 |     add    pc, #4
000a8 024             | LMM_i5
000a8 024 00 00 00 00 |     nop
000ac 025 2F 4E BC 08 |     rdlong LMM_i6, pc
000b0 026 04 5E FC 80 |     add    pc, #4
000b4 027             | LMM_i6
000b4 027 00 00 00 00 |     nop
000b8 028 2F 54 BC 08 |     rdlong LMM_i7, pc
000bc 029 04 5E FC 80 |     add    pc, #4
000c0 02a             | LMM_i7
000c0 02a 00 00 00 00 |     nop
000c4 02b 2F 5A BC 08 |     rdlong LMM_i8, pc
000c8 02c 04 5E FC 80 |     add    pc, #4
000cc 02d             | LMM_i8
000cc 02d 00 00 00 00 |     nop
000d0 02e             | LMM_jmptop
000d0 02e 16 00 7C 5C |     jmp    #LMM_LOOP
000d4 02f             | pc
000d4 02f 60 03 00 00 |     long @@@hubentry
000d8 030             | lr
000d8 030 00 00 00 00 |     long 0
000dc 031             | hubretptr
000dc 031 5C 03 00 00 |     long @@@hub_ret_to_cog
000e0 032             | LMM_NEW_PC
000e0 032 00 00 00 00 |     long   0
000e4 033             |     ' fall through
000e4 033             | LMM_CALL
000e4 033 2F 64 BC 08 |     rdlong LMM_NEW_PC, pc
000e8 034 04 5E FC 80 |     add    pc, #4
000ec 035             | LMM_CALL_PTR
000ec 035 D0 5E 3C 08 |     wrlong pc, sp
000f0 036 04 A0 FD 80 |     add    sp, #4
000f4 037             | LMM_JUMP_PTR
000f4 037 32 5E BC A0 |     mov    pc, LMM_NEW_PC
000f8 038 16 00 7C 5C |     jmp    #LMM_LOOP
000fc 039             | LMM_JUMP
000fc 039 2F 5E BC 08 |     rdlong pc, pc
00100 03a 16 00 7C 5C |     jmp    #LMM_LOOP
00104 03b             | LMM_RET
00104 03b 04 A0 FD 84 |     sub    sp, #4
00108 03c D0 5E BC 08 |     rdlong pc, sp
0010c 03d 16 00 7C 5C |     jmp    #LMM_LOOP
00110 03e             | LMM_CALL_FROM_COG
00110 03e D0 62 3C 08 |     wrlong  hubretptr, sp
00114 03f 04 A0 FD 80 |     add     sp, #4
00118 040 16 00 7C 5C |     jmp  #LMM_LOOP
0011c 041             | LMM_CALL_FROM_COG_ret
0011c 041 00 00 7C 5C |     ret
00120 042             |     
00120 042             | LMM_CALL_ret
00120 042             | LMM_CALL_PTR_ret
00120 042             | LMM_JUMP_ret
00120 042             | LMM_JUMP_PTR_ret
00120 042             | LMM_RET_ret
00120 042             | LMM_RA
00120 042 00 00 00 00 |     long	0
00124 043             |     
00124 043             | LMM_FCACHE_LOAD
00124 043 2F B6 BC 08 |     rdlong FCOUNT_, pc
00128 044 04 5E FC 80 |     add    pc, #4
0012c 045 2F B4 BC A0 |     mov    ADDR_, pc
00130 046 2F B2 BC 84 |     sub    LMM_ADDR_, pc
00134 047 54 B2 7C EC |     tjz    LMM_ADDR_, #a_fcachegoaddpc
00138 048 E7 94 FC 54 |     movd   a_fcacheldlp, #LMM_FCACHE_START
0013c 049 02 B6 FC 28 |     shr    FCOUNT_, #2
00140 04a             | a_fcacheldlp
00140 04a 2F 00 BC 08 |     rdlong 0-0, pc
00144 04b 04 5E FC 80 |     add    pc, #4
00148 04c 57 94 BC 80 |     add    a_fcacheldlp,inc_dest1
0014c 04d 4A B6 FC E4 |     djnz   FCOUNT_,#a_fcacheldlp
00150 04e             |     '' add in a JMP back out of LMM
00150 04e 09 94 FC 20 |     ror    a_fcacheldlp, #9
00154 04f 4A A2 BC 54 |     movd   a_fcachecopyjmp, a_fcacheldlp
00158 050 09 94 FC 24 |     rol    a_fcacheldlp, #9
0015c 051             | a_fcachecopyjmp
0015c 051 2E 00 BC A0 |     mov    0-0, LMM_jmptop
00160 052             | a_fcachego
00160 052 5A B2 BC A0 |     mov    LMM_ADDR_, ADDR_
00164 053 E7 CC FD 5C |     jmpret LMM_RETREG,#LMM_FCACHE_START
00168 054             | a_fcachegoaddpc
00168 054 5B 5E BC 80 |     add    pc, FCOUNT_
0016c 055 52 00 7C 5C |     jmp    #a_fcachego
00170 056             | LMM_FCACHE_LOAD_ret
00170 056 00 00 7C 5C |     ret
00174 057             | inc_dest1
00174 057 00 02 00 00 |     long (1<<9)
00178 058             | LMM_LEAVE_CODE
00178 058 E6 00 3C 5C |     jmp LMM_RETREG
0017c 059             | LMM_ADDR_
0017c 059 00 00 00 00 |     long 0
00180 05a             | ADDR_
00180 05a 00 00 00 00 |     long 0
00184 05b             | FCOUNT_
00184 05b 00 00 00 00 |     long 0
00188 05c             | COUNT_
00188 05c 00 00 00 00 |     long 0
0018c 05d             | prcnt_
0018c 05d 00 00 00 00 |     long 0
00190 05e             | pushregs_
00190 05e DB C2 FC 54 |       movd  :write, #local01
00194 05f 5C BA BC A2 |       mov   prcnt_, COUNT_ wz
00198 060 65 00 68 5C |   if_z jmp  #pushregs_done_
0019c 061             | :write
0019c 061 D0 00 3C 08 |       wrlong 0-0, sp
001a0 062 57 C2 BC 80 |       add    :write, inc_dest1
001a4 063 04 A0 FD 80 |       add    sp, #4
001a8 064 61 BA FC E4 |       djnz   prcnt_, #:write
001ac 065             | pushregs_done_
001ac 065 D0 B8 3C 08 |       wrlong COUNT_, sp
001b0 066 04 A0 FD 80 |       add    sp, #4
001b4 067 D0 3E 3D 08 |       wrlong fp, sp
001b8 068 04 A0 FD 80 |       add    sp, #4
001bc 069 D0 3E BD A0 |       mov    fp, sp
001c0 06a             | pushregs__ret
001c0 06a 00 00 7C 5C |       ret
001c4 06b             | popregs_
001c4 06b 04 A0 FD 84 |       sub   sp, #4
001c8 06c D0 3E BD 08 |       rdlong fp, sp
001cc 06d 04 A0 FD 84 |       sub   sp, #4
001d0 06e D0 B8 BC 0A |       rdlong COUNT_, sp wz
001d4 06f 77 00 68 5C |   if_z jmp  #popregs__ret
001d8 070 DB B8 FC 80 |       add   COUNT_, #local01
001dc 071 5C EA BC 54 |       movd  :read, COUNT_
001e0 072 DB B8 FC 84 |       sub   COUNT_, #local01
001e4 073             | :loop
001e4 073 57 EA BC 84 |       sub    :read, inc_dest1
001e8 074 04 A0 FD 84 |       sub    sp, #4
001ec 075             | :read
001ec 075 D0 00 BC 08 |       rdlong 0-0, sp
001f0 076 73 B8 FC E4 |       djnz   COUNT_, #:loop
001f4 077             | popregs__ret
001f4 077 00 00 7C 5C |       ret
001f8 078             | 
001f8 078             | multiply_
001f8 078 E4 70 BD A0 | 	mov	itmp2_, muldiva_
001fc 079 E5 70 BD 6C | 	xor	itmp2_, muldivb_
00200 07a E4 C8 BD A8 | 	abs	muldiva_, muldiva_
00204 07b E5 CA BD A8 | 	abs	muldivb_, muldivb_
00208 07c 7E 00 7C 5C | 	jmp	#do_multiply_
0020c 07d             | 
0020c 07d             | unsmultiply_
0020c 07d 00 70 FD A0 | 	mov	itmp2_, #0
00210 07e             | do_multiply_
00210 07e 00 9E FD A0 | 	mov	result1, #0
00214 07f 20 6E FD A0 | 	mov	itmp1_, #32
00218 080 01 C8 FD 29 | 	shr	muldiva_, #1 wc
0021c 081             | mul_lp_
0021c 081 E5 9E B1 81 |  if_c	add	result1, muldivb_ wc
00220 082 01 9E FD 31 | 	rcr	result1, #1 wc
00224 083 01 C8 FD 31 | 	rcr	muldiva_, #1 wc
00228 084 81 6E FD E4 | 	djnz	itmp1_, #mul_lp_
0022c 085 1F 70 FD 2A | 	shr	itmp2_, #31 wz
00230 086 CF CA BD BC | 	negnz	muldivb_, result1
00234 087 E4 C8 95 A6 |  if_nz	neg	muldiva_, muldiva_ wz
00238 088 01 CA D5 84 |  if_nz	sub	muldivb_, #1
0023c 089             | multiply__ret
0023c 089             | unsmultiply__ret
0023c 089 00 00 7C 5C | 	ret
00240 08a             | ' code originally from spin interpreter, modified slightly
00240 08a             | 
00240 08a             | unsdivide_
00240 08a 00 70 FD A0 |        mov     itmp2_,#0
00244 08b 91 00 7C 5C |        jmp     #udiv__
00248 08c             | 
00248 08c             | divide_
00248 08c E4 C8 BD A9 |        abs     muldiva_,muldiva_     wc       'abs(x)
0024c 08d 91 70 BD 70 |        muxc    itmp2_,divide_haxx_            'store sign of x (mov x,#1 has bits 0 and 31 set)
00250 08e E5 CA BD AB |        abs     muldivb_,muldivb_     wc,wz    'abs(y)
00254 08f 9D 00 68 5C |  if_z  jmp     #divbyzero__
00258 090 01 70 F1 6C |  if_c  xor     itmp2_,#1                      'store sign of y
0025c 091             | udiv__
0025c 091             | divide_haxx_
0025c 091 01 6E FD A0 |         mov     itmp1_,#1                    'unsigned divide (bit 0 is discarded)
00260 092 20 3C FD A0 |         mov     DIVCNT,#32
00264 093             | mdiv__
00264 093 01 CA FD 2B |         shr     muldivb_,#1        wc,wz
00268 094 01 6E FD 30 |         rcr     itmp1_,#1
0026c 095 93 3C D5 E4 |  if_nz   djnz    DIVCNT,#mdiv__
00270 096             | mdiv2__
00270 096 B7 C8 BD E1 |         cmpsub  muldiva_,itmp1_        wc
00274 097 01 CA FD 34 |         rcl     muldivb_,#1
00278 098 01 6E FD 28 |         shr     itmp1_,#1
0027c 099 96 3C FD E4 |         djnz    DIVCNT,#mdiv2__
00280 09a 1F 70 FD 2B |         shr     itmp2_,#31       wc,wz    'restore sign
00284 09b E4 C8 BD BC |         negnz   muldiva_,muldiva_         'remainder
00288 09c E5 CA BD B2 |         negc    muldivb_,muldivb_ wz      'division result
0028c 09d             | divbyzero__
0028c 09d             | divide__ret
0028c 09d             | unsdivide__ret
0028c 09d 00 00 7C 5C | 	ret
00290 09e             | DIVCNT
00290 09e 00 00 00 00 | 	long	0
00294 09f             | 
00294 09f             | fp
00294 09f 00 00 00 00 | 	long	0
00298 0a0             | imm_1000000000_
00298 0a0 00 CA 9A 3B | 	long	1000000000
0029c 0a1             | imm_1000_
0029c 0a1 E8 03 00 00 | 	long	1000
002a0 0a2             | imm_1056964608_
002a0 0a2 00 00 00 3F | 	long	1056964608
002a4 0a3             | imm_1073741824_
002a4 0a3 00 00 00 40 | 	long	1073741824
002a8 0a4             | imm_1078527525_
002a8 0a4 25 06 49 40 | 	long	1078527525
002ac 0a5             | imm_1120403456_
002ac 0a5 00 00 C8 42 | 	long	1120403456
002b0 0a6             | imm_1427211495_
002b0 0a6 E7 84 11 55 | 	long	1427211495
002b4 0a7             | imm_196608_
002b4 0a7 00 00 03 00 | 	long	196608
002b8 0a8             | imm_2147483647_
002b8 0a8 FF FF FF 7F | 	long	2147483647
002bc 0a9             | imm_2147483648_
002bc 0a9 00 00 00 80 | 	long	-2147483648
002c0 0aa             | imm_262144_
002c0 0aa 00 00 04 00 | 	long	262144
002c4 0ab             | imm_327680_
002c4 0ab 00 00 05 00 | 	long	327680
002c8 0ac             | imm_393216_
002c8 0ac 00 00 06 00 | 	long	393216
002cc 0ad             | imm_4294967264_
002cc 0ad E0 FF FF FF | 	long	-32
002d0 0ae             | imm_4294967273_
002d0 0ae E9 FF FF FF | 	long	-23
002d4 0af             | imm_4294967295_
002d4 0af FF FF FF FF | 	long	-1
002d8 0b0             | imm_536870912_
002d8 0b0 00 00 00 20 | 	long	536870912
002dc 0b1             | imm_65532_
002dc 0b1 FC FF 00 00 | 	long	65532
002e0 0b2             | imm_655360_
002e0 0b2 00 00 0A 00 | 	long	655360
002e4 0b3             | imm_65536_
002e4 0b3 00 00 01 00 | 	long	65536
002e8 0b4             | imm_720896_
002e8 0b4 00 00 0B 00 | 	long	720896
002ec 0b5             | imm_8388607_
002ec 0b5 FF FF 7F 00 | 	long	8388607
002f0 0b6             | imm_9600_
002f0 0b6 80 25 00 00 | 	long	9600
002f4 0b7             | itmp1_
002f4 0b7 00 00 00 00 | 	long	0
002f8 0b8             | itmp2_
002f8 0b8 00 00 00 00 | 	long	0
002fc 0b9             | objptr
002fc 0b9 20 29 00 00 | 	long	@@@objmem
00300 0ba             | ptr_L__0073_
00300 0ba 4C 1E 00 00 | 	long	@@@LR__0122
00304 0bb             | ptr_L__0074_
00304 0bb 52 1E 00 00 | 	long	@@@LR__0123
00308 0bc             | ptr_L__0075_
00308 0bc 6C 1E 00 00 | 	long	@@@LR__0124
0030c 0bd             | ptr_L__0076_
0030c 0bd 74 1E 00 00 | 	long	@@@LR__0125
00310 0be             | ptr_L__0077_
00310 0be 79 1E 00 00 | 	long	@@@LR__0126
00314 0bf             | ptr_L__0078_
00314 0bf 81 1E 00 00 | 	long	@@@LR__0127
00318 0c0             | ptr_L__0079_
00318 0c0 8B 1E 00 00 | 	long	@@@LR__0128
0031c 0c1             | ptr_L__0080_
0031c 0c1 94 1E 00 00 | 	long	@@@LR__0129
00320 0c2             | ptr_L__0083_
00320 0c2 9F 1E 00 00 | 	long	@@@LR__0130
00324 0c3             | ptr_L__0084_
00324 0c3 A8 1E 00 00 | 	long	@@@LR__0131
00328 0c4             | ptr_L__0085_
00328 0c4 B3 1E 00 00 | 	long	@@@LR__0132
0032c 0c5             | ptr_L__0086_
0032c 0c5 C2 1E 00 00 | 	long	@@@LR__0133
00330 0c6             | ptr_L__0087_
00330 0c6 D3 1E 00 00 | 	long	@@@LR__0134
00334 0c7             | ptr_L__0088_
00334 0c7 E3 1E 00 00 | 	long	@@@LR__0135
00338 0c8             | ptr_L__0089_
00338 0c8 E7 1E 00 00 | 	long	@@@LR__0136
0033c 0c9             | ptr_L__0090_
0033c 0c9 F7 1E 00 00 | 	long	@@@LR__0137
00340 0ca             | ptr__Float32_dat__
00340 0ca BC 21 00 00 | 	long	@@@_Float32_dat_
00344 0cb             | ptr__FloatString_dat__
00344 0cb 54 20 00 00 | 	long	@@@_FloatString_dat_
00348 0cc             | ptr__FullDuplexSerialAvail_dat__
00348 0cc FC 1E 00 00 | 	long	@@@_FullDuplexSerialAvail_dat_
0034c 0cd             | ptr__Numbers_dat__
0034c 0cd 4C 20 00 00 | 	long	@@@_Numbers_dat_
00350 0ce             | ptr_hubexit_
00350 0ce 18 1D 00 00 | 	long	@@@hubexit
00354 0cf             | result1
00354 0cf 00 00 00 00 | 	long	0
00358 0d0             | sp
00358 0d0 64 2A 00 00 | 	long	@@@stackspace
0035c 0d1             | COG_BSS_START
0035c 0d1             | 	fit	496
0035c 0d1             | hub_ret_to_cog
0035c 0d1 41 00 7C 5C | 	jmp	#LMM_CALL_FROM_COG_ret
00360 0d2             | hubentry
00360 0d2             | 
00360 0d2             | '   fstr        : "FloatString"
00360 0d2             | ' 
00360 0d2             | ' PUB main | ms, last_cnt, current_cnt, f_tpi, f_rot, temp
00360 0d2             | _main
00360 0d2 03 B8 FC A0 | 	mov	COUNT_, #3
00364 0d3 5E D4 FC 5C | 	call	#pushregs_
00368 0d4             | ' 
00368 0d4             | '   meguno.start(RX, TX, 9_600)
00368 0d4 1F AC FD A0 | 	mov	arg01, #31
0036c 0d5 1E AE FD A0 | 	mov	arg02, #30
00370 0d6 B6 B0 BD A0 | 	mov	arg03, imm_9600_
00374 0d7 14 72 FD 80 | 	add	objptr, #20
00378 0d8 33 84 FC 5C | 	call	#LMM_CALL
0037c 0d9 BC 05 00 00 | 	long	@@@_megunolink_ez_start
00380 0da             | '   f.start
00380 0da E4 72 FD 80 | 	add	objptr, #228
00384 0db 33 84 FC 5C | 	call	#LMM_CALL
00388 0dc 54 1A 00 00 | 	long	@@@_Float32_start
0038c 0dd             | ' 
0038c 0dd             | '   ms := 0
0038c 0dd 00 B6 FD A0 | 	mov	local01, #0
00390 0de             | ' 
00390 0de             | '   ' Create some data to send. Here, a value from sine and cosine curves.
00390 0de             | '   f_frequency := 0.5
00390 0de A2 AE BD A0 | 	mov	arg02, imm_1056964608_
00394 0df EC 72 FD 84 | 	sub	objptr, #236
00398 0e0 B9 AE 3D 08 | 	wrlong	arg02, objptr
0039c 0e1             | '   f_phase := f.fdiv(3.141, 2.0)
0039c 0e1 A4 AC BD A0 | 	mov	arg01, imm_1078527525_
003a0 0e2 A3 AE BD A0 | 	mov	arg02, imm_1073741824_
003a4 0e3 EC 72 FD 80 | 	add	objptr, #236
003a8 0e4 33 84 FC 5C | 	call	#LMM_CALL
003ac 0e5 7C 1B 00 00 | 	long	@@@_Float32_FDiv
003b0 0e6 E8 72 FD 84 | 	sub	objptr, #232
003b4 0e7 B9 9E 3D 08 | 	wrlong	result1, objptr
003b8 0e8             | '   f_tPi := f.fMul(2.0, 3.141)
003b8 0e8 A3 AC BD A0 | 	mov	arg01, imm_1073741824_
003bc 0e9 A4 AE BD A0 | 	mov	arg02, imm_1078527525_
003c0 0ea E8 72 FD 80 | 	add	objptr, #232
003c4 0eb 33 84 FC 5C | 	call	#LMM_CALL
003c8 0ec 20 1B 00 00 | 	long	@@@_Float32_FMul
003cc 0ed CF AC BD A0 | 	mov	arg01, result1
003d0 0ee             | '   f_rot := f.fMul(f_tPi, f_frequency)
003d0 0ee EC 72 FD 84 | 	sub	objptr, #236
003d4 0ef B9 AE BD 08 | 	rdlong	arg02, objptr
003d8 0f0 EC 72 FD 80 | 	add	objptr, #236
003dc 0f1 33 84 FC 5C | 	call	#LMM_CALL
003e0 0f2 20 1B 00 00 | 	long	@@@_Float32_FMul
003e4 0f3 CF B8 BD A0 | 	mov	local02, result1
003e8 0f4             | ' 
003e8 0f4             | '   meguno.writeTplotSet(string("title"), string("Sine and Cosine Waveforms"))
003e8 0f4 BA AC BD A0 | 	mov	arg01, ptr_L__0073_
003ec 0f5 BB AE BD A0 | 	mov	arg02, ptr_L__0074_
003f0 0f6 E4 72 FD 84 | 	sub	objptr, #228
003f4 0f7 33 84 FC 5C | 	call	#LMM_CALL
003f8 0f8 04 06 00 00 | 	long	@@@_megunolink_ez_writeTplotSet
003fc 0f9             | '   meguno.writeTplotSet(string("x-label"), string("Time"))
003fc 0f9 BC AC BD A0 | 	mov	arg01, ptr_L__0075_
00400 0fa BD AE BD A0 | 	mov	arg02, ptr_L__0076_
00404 0fb 33 84 FC 5C | 	call	#LMM_CALL
00408 0fc 04 06 00 00 | 	long	@@@_megunolink_ez_writeTplotSet
0040c 0fd             | '   meguno.writeTplotSet(string("y-label"), string("Amplitude"))
0040c 0fd BE AC BD A0 | 	mov	arg01, ptr_L__0077_
00410 0fe BF AE BD A0 | 	mov	arg02, ptr_L__0078_
00414 0ff 33 84 FC 5C | 	call	#LMM_CALL
00418 100 04 06 00 00 | 	long	@@@_megunolink_ez_writeTplotSet
0041c 101             | ' 
0041c 101             | '   meguno.writeTplotStyle(string("Sinewave"), "b", "s", "_", 2)
0041c 101 C0 AC BD A0 | 	mov	arg01, ptr_L__0079_
00420 102 62 AE FD A0 | 	mov	arg02, #98
00424 103 73 B0 FD A0 | 	mov	arg03, #115
00428 104 5F B2 FD A0 | 	mov	arg04, #95
0042c 105 02 B4 FD A0 | 	mov	arg05, #2
00430 106 33 84 FC 5C | 	call	#LMM_CALL
00434 107 70 06 00 00 | 	long	@@@_megunolink_ez_writeTplotStyle
00438 108             | '   meguno.writeTplotStyle(string("Cosinewave"), "r", "d", ";", 2)
00438 108 C1 AC BD A0 | 	mov	arg01, ptr_L__0080_
0043c 109 72 AE FD A0 | 	mov	arg02, #114
00440 10a 64 B0 FD A0 | 	mov	arg03, #100
00444 10b 3B B2 FD A0 | 	mov	arg04, #59
00448 10c 02 B4 FD A0 | 	mov	arg05, #2
0044c 10d 33 84 FC 5C | 	call	#LMM_CALL
00450 10e 70 06 00 00 | 	long	@@@_megunolink_ez_writeTplotStyle
00454 10f 14 72 FD 84 | 	sub	objptr, #20
00458 110             | ' 
00458 110             | '   last_cnt := cnt
00458 110 F1 BB BD A0 | 	mov	local03, cnt
0045c 111             | '   'ms := (clkfreq / 1000 )+ last_cnt                             'ms counter
0045c 111             | ' 
0045c 111             | '   repeat
0045c 111             | LR__0001
0045c 111             | '     meguno.listen               ' WARNING: This function must be called repeatedly to response touch events
0045c 111 14 72 FD 80 | 	add	objptr, #20
00460 112 33 84 FC 5C | 	call	#LMM_CALL
00464 113 14 08 00 00 | 	long	@@@_megunolink_ez_listen
00468 114 14 72 FD 84 | 	sub	objptr, #20
0046c 115             | '                                 ' from Nextion touch panel. Actually, you should place it in your loop function.
0046c 115             | '     current_cnt := cnt
0046c 115 F1 B1 BD A0 | 	mov	arg03, cnt
00470 116             | '     ms += (current_cnt - last_cnt) / (clkfreq / 1000 )
00470 116 D8 AE BD A0 | 	mov	arg02, arg03
00474 117 DD AE BD 84 | 	sub	arg02, local03
00478 118 00 C8 FD 08 | 	rdlong	muldiva_, #0
0047c 119 A1 CA BD A0 | 	mov	muldivb_, imm_1000_
00480 11a 8C 3A FD 5C | 	call	#divide_
00484 11b D7 C8 BD A0 | 	mov	muldiva_, arg02
00488 11c 8C 3A FD 5C | 	call	#divide_
0048c 11d E5 B6 BD 80 | 	add	local01, muldivb_
00490 11e             | '     last_cnt := current_cnt
00490 11e D8 BA BD A0 | 	mov	local03, arg03
00494 11f             | ' 
00494 11f             | '     f_seconds := f.fDiv(f.FFloat(ms), f.FFloat(1000))
00494 11f DB AC BD A0 | 	mov	arg01, local01
00498 120 F8 72 FD 80 | 	add	objptr, #248
0049c 121 33 84 FC 5C | 	call	#LMM_CALL
004a0 122 D8 1B 00 00 | 	long	@@@_Float32_FFloat
004a4 123 CF B0 BD A0 | 	mov	arg03, result1
004a8 124 A1 AC BD A0 | 	mov	arg01, imm_1000_
004ac 125 33 84 FC 5C | 	call	#LMM_CALL
004b0 126 D8 1B 00 00 | 	long	@@@_Float32_FFloat
004b4 127 CF AE BD A0 | 	mov	arg02, result1
004b8 128 D8 AC BD A0 | 	mov	arg01, arg03
004bc 129 33 84 FC 5C | 	call	#LMM_CALL
004c0 12a 7C 1B 00 00 | 	long	@@@_Float32_FDiv
004c4 12b F0 72 FD 84 | 	sub	objptr, #240
004c8 12c B9 9E 3D 08 | 	wrlong	result1, objptr
004cc 12d             | ' 
004cc 12d             | '     'Send Data To MegunoLink.
004cc 12d             | '     f_y :=  f.sin(f.fMul(f_rot, f_seconds))
004cc 12d CF AE BD A0 | 	mov	arg02, result1
004d0 12e DC AC BD A0 | 	mov	arg01, local02
004d4 12f F0 72 FD 80 | 	add	objptr, #240
004d8 130 33 84 FC 5C | 	call	#LMM_CALL
004dc 131 20 1B 00 00 | 	long	@@@_Float32_FMul
004e0 132 CF AC BD A0 | 	mov	arg01, result1
004e4 133 33 84 FC 5C | 	call	#LMM_CALL
004e8 134 78 1C 00 00 | 	long	@@@_Float32_Sin
004ec 135 F8 72 FD 84 | 	sub	objptr, #248
004f0 136 B9 9E 3D 08 | 	wrlong	result1, objptr
004f4 137             | '             'sin(2 * 3.141 * f_frequency * f_seconds)
004f4 137             | '     f_y2 := f.cos(f.fAdd(f.fMul(f_rot, f_seconds), f_phase))
004f4 137 08 72 FD 80 | 	add	objptr, #8
004f8 138 B9 AE BD 08 | 	rdlong	arg02, objptr
004fc 139 DC AC BD A0 | 	mov	arg01, local02
00500 13a F0 72 FD 80 | 	add	objptr, #240
00504 13b 33 84 FC 5C | 	call	#LMM_CALL
00508 13c 20 1B 00 00 | 	long	@@@_Float32_FMul
0050c 13d CF AC BD A0 | 	mov	arg01, result1
00510 13e E8 72 FD 84 | 	sub	objptr, #232
00514 13f B9 AE BD 08 | 	rdlong	arg02, objptr
00518 140 E8 72 FD 80 | 	add	objptr, #232
0051c 141 33 84 FC 5C | 	call	#LMM_CALL
00520 142 C4 1A 00 00 | 	long	@@@_Float32_FAdd
00524 143 CF AC BD A0 | 	mov	arg01, result1
00528 144 33 84 FC 5C | 	call	#LMM_CALL
0052c 145 C8 1C 00 00 | 	long	@@@_Float32_Cos
00530 146 F4 72 FD 84 | 	sub	objptr, #244
00534 147 B9 9E 3D 08 | 	wrlong	result1, objptr
00538 148 04 72 FD 84 | 	sub	objptr, #4
0053c 149             | '             'cos(2 * 3.141 * f_frequency * f_seconds + f_phase)
0053c 149             | '             
0053c 149             | '     'values can be sent as integers, floats or fixed point
0053c 149             | '     
0053c 149             | '     'float has a precision argument that selects how many total digits of precision to send
0053c 149             | '     meguno.writeTplotFloat(string("Sinewave"), f_y, 2)
0053c 149 C2 AC BD A0 | 	mov	arg01, ptr_L__0083_
00540 14a B9 AE BD 08 | 	rdlong	arg02, objptr
00544 14b 02 B0 FD A0 | 	mov	arg03, #2
00548 14c 14 72 FD 80 | 	add	objptr, #20
0054c 14d 33 84 FC 5C | 	call	#LMM_CALL
00550 14e 8C 07 00 00 | 	long	@@@_megunolink_ez_writeTplotFloat
00554 14f             | '     'meguno.writeTplotFloat(string("Cosinewave"), f_y2, 2)
00554 14f             | '     
00554 14f             | '     'fixed point will display send with the given number of decimal places
00554 14f             | '     'the provided value is effetively divided by the number of decimal places
00554 14f             | '     temp := f.ftrunc(f.fMul(f_y2, 100.0))  'first we need an integer that has the extra digits we need
00554 14f 10 72 FD 84 | 	sub	objptr, #16
00558 150 B9 AC BD 08 | 	rdlong	arg01, objptr
0055c 151 A5 AE BD A0 | 	mov	arg02, imm_1120403456_
00560 152 F4 72 FD 80 | 	add	objptr, #244
00564 153 33 84 FC 5C | 	call	#LMM_CALL
00568 154 20 1B 00 00 | 	long	@@@_Float32_FMul
0056c 155 CF AC BD A0 | 	mov	arg01, result1
00570 156 33 84 FC 5C | 	call	#LMM_CALL
00574 157 28 1C 00 00 | 	long	@@@_Float32_FTrunc
00578 158 CF AE BD A0 | 	mov	arg02, result1
0057c 159             | '     meguno.writeTplotFixed(string("Cosinewave"), temp, 2) 'now we pass the int to MegunoLink
0057c 159 C3 AC BD A0 | 	mov	arg01, ptr_L__0084_
00580 15a 02 B0 FD A0 | 	mov	arg03, #2
00584 15b E4 72 FD 84 | 	sub	objptr, #228
00588 15c 33 84 FC 5C | 	call	#LMM_CALL
0058c 15d 0C 07 00 00 | 	long	@@@_megunolink_ez_writeTplotFixed
00590 15e 14 72 FD 84 | 	sub	objptr, #20
00594 15f             | ' 
00594 15f             | ' 
00594 15f             | '     waitcnt(clkfreq / 100 + cnt)                       'delay so we don't overwhelm the serial channel
00594 15f 00 C8 FD 08 | 	rdlong	muldiva_, #0
00598 160 64 CA FD A0 | 	mov	muldivb_, #100
0059c 161 8C 3A FD 5C | 	call	#divide_
005a0 162 E5 AC BD A0 | 	mov	arg01, muldivb_
005a4 163 F1 AD BD 80 | 	add	arg01, cnt
005a8 164 00 AC FD F8 | 	waitcnt	arg01, #0
005ac 165 54 5F FC 84 | 	sub	pc, #4*(($+1) - LR__0001)
005b0 166 9F A0 BD A0 | 	mov	sp, fp
005b4 167 6B EE FC 5C | 	call	#popregs_
005b8 168             | _main_ret
005b8 168 3B 84 FC 5C | 	call	#LMM_RET
005bc 169             | 
005bc 169             | '   fMath         : "FloatMath"
005bc 169             | ' 
005bc 169             | ' PUB start(rxPin, txPin, baud)                        'Must be run before using object
005bc 169             | _megunolink_ez_start
005bc 169             | ' {{
005bc 169             | ' }}
005bc 169             | '   meguno.start(rxPin, txPin, SERIAL_MODE, baud)
005bc 169 D8 B2 BD A0 | 	mov	arg04, arg03
005c0 16a 00 B0 FD A0 | 	mov	arg03, #0
005c4 16b 14 72 FD 80 | 	add	objptr, #20
005c8 16c 33 84 FC 5C | 	call	#LMM_CALL
005cc 16d 1C 0B 00 00 | 	long	@@@_FullDuplexSerialAvail_Start
005d0 16e 14 72 FD 84 | 	sub	objptr, #20
005d4 16f             | '   waitcnt(clkfreq / 100 + cnt)                          'wait for serial to init
005d4 16f 00 C8 FD 08 | 	rdlong	muldiva_, #0
005d8 170 64 CA FD A0 | 	mov	muldivb_, #100
005dc 171 8C 3A FD 5C | 	call	#divide_
005e0 172 E5 AC BD A0 | 	mov	arg01, muldivb_
005e4 173 F1 AD BD 80 | 	add	arg01, cnt
005e8 174 00 AC FD F8 | 	waitcnt	arg01, #0
005ec 175             | '   convertNum.init
005ec 175 5C 72 FD 80 | 	add	objptr, #92
005f0 176             | ' ''Initialize to default settings.  Init MUST be called before first object use.
005f0 176             | ' ''  ┌──────────────────────────────────────────────────┐
005f0 176             | ' ''  │             DEFAULT SPECIAL SYMBOLS              │
005f0 176             | ' ''  ├─────┬──────┬─────────────────────────────────────┤
005f0 176             | ' ''  │ ID  │ Char │ Usage                               │
005f0 176             | ' ''  ├─────┼──────┼─────────────────────────────────────┤
005f0 176             | ' ''  │  1  │  ,   │ Comma (digit group separator)       │
005f0 176             | ' ''  │  2  │  _   │ Underscore (digit group separator)  │
005f0 176             | ' ''  │  3  │  $   │ Dollar Sign (Hexadecimal indicator) │
005f0 176             | ' ''  │  4  │  %   │ Percent Sign (Binary indicator)     │
005f0 176             | ' ''  │ 5-7 │      │ Unused (User definable via Config)  │
005f0 176             | ' ''  └─────┴──────┴─────────────────────────────────────┘
005f0 176             | '   Config(@DefaultSymbols)
005f0 176 CD AC BD A0 | 	mov	arg01, ptr__Numbers_dat__
005f4 177 33 84 FC 5C | 	call	#LMM_CALL
005f8 178 8C 0E 00 00 | 	long	@@@_Numbers_Config
005fc 179 5C 72 FD 84 | 	sub	objptr, #92
00600 17a             | _megunolink_ez_start_ret
00600 17a 3B 84 FC 5C | 	call	#LMM_RET
00604 17b             | 
00604 17b             | ' 
00604 17b             | ' PUB writeTplotSet(ptr_attrib, ptr_txt)
00604 17b             | _megunolink_ez_writeTplotSet
00604 17b 02 B8 FC A0 | 	mov	COUNT_, #2
00608 17c 5E D4 FC 5C | 	call	#pushregs_
0060c 17d D6 B6 BD A0 | 	mov	local01, arg01
00610 17e D7 B8 BD A0 | 	mov	local02, arg02
00614 17f             | '   meguno.str(string("{TIMEPLOT|SET|"))
00614 17f C4 AC BD A0 | 	mov	arg01, ptr_L__0085_
00618 180 14 72 FD 80 | 	add	objptr, #20
0061c 181 33 84 FC 5C | 	call	#LMM_CALL
00620 182 74 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Str
00624 183             | '   meguno.str(ptr_attrib)
00624 183 DB AC BD A0 | 	mov	arg01, local01
00628 184 33 84 FC 5C | 	call	#LMM_CALL
0062c 185 74 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Str
00630 186             | '   meguno.tx("=")
00630 186 3D AC FD A0 | 	mov	arg01, #61
00634 187 33 84 FC 5C | 	call	#LMM_CALL
00638 188 E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
0063c 189             | '   meguno.str(ptr_txt)
0063c 189 DC AC BD A0 | 	mov	arg01, local02
00640 18a 33 84 FC 5C | 	call	#LMM_CALL
00644 18b 74 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Str
00648 18c             | '   meguno.tx("}")
00648 18c 7D AC FD A0 | 	mov	arg01, #125
0064c 18d 33 84 FC 5C | 	call	#LMM_CALL
00650 18e E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
00654 18f             | '   meguno.tx(CR)
00654 18f 0A AC FD A0 | 	mov	arg01, #10
00658 190 33 84 FC 5C | 	call	#LMM_CALL
0065c 191 E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
00660 192 14 72 FD 84 | 	sub	objptr, #20
00664 193 9F A0 BD A0 | 	mov	sp, fp
00668 194 6B EE FC 5C | 	call	#popregs_
0066c 195             | _megunolink_ez_writeTplotSet_ret
0066c 195 3B 84 FC 5C | 	call	#LMM_RET
00670 196             | 
00670 196             | ' 
00670 196             | ' PUB writeTplotStyle(ptr_channel, color, marker, style, width)
00670 196             | _megunolink_ez_writeTplotStyle
00670 196 05 B8 FC A0 | 	mov	COUNT_, #5
00674 197 5E D4 FC 5C | 	call	#pushregs_
00678 198 D6 B6 BD A0 | 	mov	local01, arg01
0067c 199 D7 B8 BD A0 | 	mov	local02, arg02
00680 19a D8 BA BD A0 | 	mov	local03, arg03
00684 19b D9 BC BD A0 | 	mov	local04, arg04
00688 19c DA BE BD A0 | 	mov	local05, arg05
0068c 19d             | '   meguno.str(string("{TIMEPLOT|STYLE|"))
0068c 19d C5 AC BD A0 | 	mov	arg01, ptr_L__0086_
00690 19e 14 72 FD 80 | 	add	objptr, #20
00694 19f 33 84 FC 5C | 	call	#LMM_CALL
00698 1a0 74 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Str
0069c 1a1             | '   meguno.str(ptr_channel)
0069c 1a1 DB AC BD A0 | 	mov	arg01, local01
006a0 1a2 33 84 FC 5C | 	call	#LMM_CALL
006a4 1a3 74 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Str
006a8 1a4             | '   meguno.tx(":")
006a8 1a4 3A AC FD A0 | 	mov	arg01, #58
006ac 1a5 33 84 FC 5C | 	call	#LMM_CALL
006b0 1a6 E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
006b4 1a7             | '   meguno.tx(color)
006b4 1a7 DC AC BD A0 | 	mov	arg01, local02
006b8 1a8 33 84 FC 5C | 	call	#LMM_CALL
006bc 1a9 E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
006c0 1aa             | '   meguno.tx(marker)
006c0 1aa DD AC BD A0 | 	mov	arg01, local03
006c4 1ab 33 84 FC 5C | 	call	#LMM_CALL
006c8 1ac E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
006cc 1ad             | '   meguno.tx(style)
006cc 1ad DE AC BD A0 | 	mov	arg01, local04
006d0 1ae 33 84 FC 5C | 	call	#LMM_CALL
006d4 1af E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
006d8 1b0             | '   meguno.dec(width)
006d8 1b0 DF AC BD A0 | 	mov	arg01, local05
006dc 1b1 33 84 FC 5C | 	call	#LMM_CALL
006e0 1b2 B4 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Dec
006e4 1b3             | '   meguno.tx("}")
006e4 1b3 7D AC FD A0 | 	mov	arg01, #125
006e8 1b4 33 84 FC 5C | 	call	#LMM_CALL
006ec 1b5 E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
006f0 1b6             | '   meguno.tx(CR)
006f0 1b6 0A AC FD A0 | 	mov	arg01, #10
006f4 1b7 33 84 FC 5C | 	call	#LMM_CALL
006f8 1b8 E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
006fc 1b9 14 72 FD 84 | 	sub	objptr, #20
00700 1ba 9F A0 BD A0 | 	mov	sp, fp
00704 1bb 6B EE FC 5C | 	call	#popregs_
00708 1bc             | _megunolink_ez_writeTplotStyle_ret
00708 1bc 3B 84 FC 5C | 	call	#LMM_RET
0070c 1bd             | 
0070c 1bd             | ' 
0070c 1bd             | ' PUB writeTplotFixed(ptr_channel, val, dec_places)
0070c 1bd             | _megunolink_ez_writeTplotFixed
0070c 1bd 01 B8 FC A0 | 	mov	COUNT_, #1
00710 1be 5E D4 FC 5C | 	call	#pushregs_
00714 1bf D6 B6 BD A0 | 	mov	local01, arg01
00718 1c0             | '   intToFixed(val, dec_places)
00718 1c0 D7 AC BD A0 | 	mov	arg01, arg02
0071c 1c1 D8 AE BD A0 | 	mov	arg02, arg03
00720 1c2 33 84 FC 5C | 	call	#LMM_CALL
00724 1c3 68 09 00 00 | 	long	@@@_megunolink_ez_intToFixed
00728 1c4             | '   meguno.str(string("{TIMEPLOT|DATA|"))
00728 1c4 C6 AC BD A0 | 	mov	arg01, ptr_L__0087_
0072c 1c5 14 72 FD 80 | 	add	objptr, #20
00730 1c6 33 84 FC 5C | 	call	#LMM_CALL
00734 1c7 74 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Str
00738 1c8             | '   meguno.str(ptr_channel)
00738 1c8 DB AC BD A0 | 	mov	arg01, local01
0073c 1c9 33 84 FC 5C | 	call	#LMM_CALL
00740 1ca 74 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Str
00744 1cb             | '   meguno.str(string("|T|"))
00744 1cb C7 AC BD A0 | 	mov	arg01, ptr_L__0088_
00748 1cc 33 84 FC 5C | 	call	#LMM_CALL
0074c 1cd 74 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Str
00750 1ce             | '   meguno.str(@temp_string)
00750 1ce 11 72 FD 84 | 	sub	objptr, #17
00754 1cf B9 AC BD A0 | 	mov	arg01, objptr
00758 1d0 11 72 FD 80 | 	add	objptr, #17
0075c 1d1 33 84 FC 5C | 	call	#LMM_CALL
00760 1d2 74 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Str
00764 1d3             | '   meguno.tx("}")
00764 1d3 7D AC FD A0 | 	mov	arg01, #125
00768 1d4 33 84 FC 5C | 	call	#LMM_CALL
0076c 1d5 E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
00770 1d6             | '   meguno.tx(CR)
00770 1d6 0A AC FD A0 | 	mov	arg01, #10
00774 1d7 33 84 FC 5C | 	call	#LMM_CALL
00778 1d8 E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
0077c 1d9 14 72 FD 84 | 	sub	objptr, #20
00780 1da 9F A0 BD A0 | 	mov	sp, fp
00784 1db 6B EE FC 5C | 	call	#popregs_
00788 1dc             | _megunolink_ez_writeTplotFixed_ret
00788 1dc 3B 84 FC 5C | 	call	#LMM_RET
0078c 1dd             | 
0078c 1dd             | ' 
0078c 1dd             | ' PUB writeTplotFloat(ptr_channel, val, precision)
0078c 1dd             | _megunolink_ez_writeTplotFloat
0078c 1dd 02 B8 FC A0 | 	mov	COUNT_, #2
00790 1de 5E D4 FC 5C | 	call	#pushregs_
00794 1df D6 B6 BD A0 | 	mov	local01, arg01
00798 1e0 D7 B8 BD A0 | 	mov	local02, arg02
0079c 1e1             | '   convertFloat.SetPrecision(precision)
0079c 1e1             | ' 
0079c 1e1             | ' ''Set precision to express floating-point numbers in
0079c 1e1             | ' ''
0079c 1e1             | ' ''  NumberOfDigits = Number of digits to round to, limited to 1..7 (7=default)
0079c 1e1             | ' ''
0079c 1e1             | ' ''  examples          results
0079c 1e1             | ' ''  -------------------------------
0079c 1e1             | ' ''  SetPrecision(1)   "1e+0"
0079c 1e1             | ' ''  SetPrecision(4)   "1.000e+0"
0079c 1e1             | ' ''  SetPrecision(7)   "1.000000e+0"
0079c 1e1             | ' 
0079c 1e1             | '   precision := NumberOfDigits
0079c 1e1 BC 72 FD 80 | 	add	objptr, #188
007a0 1e2 B9 B0 3D 08 | 	wrlong	arg03, objptr
007a4 1e3             | '   meguno.str(string("{TIMEPLOT|DATA|"))
007a4 1e3 C8 AC BD A0 | 	mov	arg01, ptr_L__0089_
007a8 1e4 A8 72 FD 84 | 	sub	objptr, #168
007ac 1e5 33 84 FC 5C | 	call	#LMM_CALL
007b0 1e6 74 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Str
007b4 1e7             | '   meguno.str(ptr_channel)
007b4 1e7 DB AC BD A0 | 	mov	arg01, local01
007b8 1e8 33 84 FC 5C | 	call	#LMM_CALL
007bc 1e9 74 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Str
007c0 1ea             | '   meguno.str(string("|T|"))
007c0 1ea C9 AC BD A0 | 	mov	arg01, ptr_L__0090_
007c4 1eb 33 84 FC 5C | 	call	#LMM_CALL
007c8 1ec 74 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Str
007cc 1ed             | '   meguno.str(convertFloat.floatToString(val))
007cc 1ed DC AC BD A0 | 	mov	arg01, local02
007d0 1ee 90 72 FD 80 | 	add	objptr, #144
007d4 1ef 33 84 FC 5C | 	call	#LMM_CALL
007d8 1f0 AC 0E 00 00 | 	long	@@@_FloatString_FloatToString
007dc 1f1 CF AC BD A0 | 	mov	arg01, result1
007e0 1f2 90 72 FD 84 | 	sub	objptr, #144
007e4 1f3 33 84 FC 5C | 	call	#LMM_CALL
007e8 1f4 74 0D 00 00 | 	long	@@@_FullDuplexSerialAvail_Str
007ec 1f5             | '   meguno.tx("}")
007ec 1f5 7D AC FD A0 | 	mov	arg01, #125
007f0 1f6 33 84 FC 5C | 	call	#LMM_CALL
007f4 1f7 E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
007f8 1f8             | '   meguno.tx(CR)
007f8 1f8 0A AC FD A0 | 	mov	arg01, #10
007fc 1f9 33 84 FC 5C | 	call	#LMM_CALL
00800 1fa E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
00804 1fb 14 72 FD 84 | 	sub	objptr, #20
00808 1fc 9F A0 BD A0 | 	mov	sp, fp
0080c 1fd 6B EE FC 5C | 	call	#popregs_
00810 1fe             | _megunolink_ez_writeTplotFloat_ret
00810 1fe 3B 84 FC 5C | 	call	#LMM_RET
00814 1ff             | 
00814 1ff             | ' 
00814 1ff             | ' PUB listen | _char, _time, _ms, _len, _cmdFound, _cmd      'check for incoming serial data from nextion, must be run frequently to respond to events
00814 1ff             | _megunolink_ez_listen
00814 1ff 04 B8 FC A0 | 	mov	COUNT_, #4
00818 200 5E D4 FC 5C | 	call	#pushregs_
0081c 201             | ' {{
0081c 201             | ' }}
0081c 201             | '   cmd_avail := false
0081c 201 00 AC FD A0 | 	mov	arg01, #0
00820 202 02 72 FD 80 | 	add	objptr, #2
00824 203 B9 AC 3D 00 | 	wrbyte	arg01, objptr
00828 204             | ' 
00828 204             | '   if meguno.available > 2                             'Read if more then 2 bytes come (we always send more than 2 <#> <len> <cmd> <id>
00828 204 12 72 FD 80 | 	add	objptr, #18
0082c 205 33 84 FC 5C | 	call	#LMM_CALL
00830 206 1C 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Available
00834 207 14 72 FD 84 | 	sub	objptr, #20
00838 208 03 9E 7D C1 | 	cmps	result1, #3 wc
0083c 209 1C 5F F0 80 |  if_b	add	pc, #4*(LR__0008 - ($+1))
00840 20a             | '     _char := meguno.rxTime(100)
00840 20a 64 AC FD A0 | 	mov	arg01, #100
00844 20b 14 72 FD 80 | 	add	objptr, #20
00848 20c 33 84 FC 5C | 	call	#LMM_CALL
0084c 20d 94 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_RxTime
00850 20e 14 72 FD 84 | 	sub	objptr, #20
00854 20f CF B6 BD A0 | 	mov	local01, result1
00858 210             | '     if _char == -1                                     'if timeout (-1) return error (-1)
00858 210 AF B6 3D 86 | 	cmp	local01, imm_4294967295_ wz
0085c 211             | '       return
0085c 211 FC 5E E8 80 |  if_e	add	pc, #4*(LR__0009 - ($+1))
00860 212             | ' 
00860 212             | '     _time := cnt
00860 212 F1 B9 BD A0 | 	mov	local02, cnt
00864 213             | '     _ms := 100
00864 213 64 BA FD A0 | 	mov	local03, #100
00868 214             | ' 
00868 214             | '     repeat while _char <> "#"
00868 214             | LR__0002
00868 214 23 B6 7D 86 | 	cmp	local01, #35 wz
0086c 215 48 5E E8 80 |  if_e	add	pc, #4*(LR__0003 - ($+1))
00870 216             | '       _char := meguno.rxTime(100)
00870 216 64 AC FD A0 | 	mov	arg01, #100
00874 217 14 72 FD 80 | 	add	objptr, #20
00878 218 33 84 FC 5C | 	call	#LMM_CALL
0087c 219 94 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_RxTime
00880 21a 14 72 FD 84 | 	sub	objptr, #20
00884 21b CF B6 BD A0 | 	mov	local01, result1
00888 21c             | '       if _char == -1                                     'if timeout (-1) return error (-1)
00888 21c AF B6 3D 86 | 	cmp	local01, imm_4294967295_ wz
0088c 21d             | '         return
0088c 21d CC 5E E8 80 |  if_e	add	pc, #4*(LR__0009 - ($+1))
00890 21e             | ' 
00890 21e             | '       if(cnt - _time) / (clkfreq / 1000) > _ms                                'time out if we don't see a start char
00890 21e F1 AD BD A0 | 	mov	arg01, cnt
00894 21f DC AC BD 84 | 	sub	arg01, local02
00898 220 00 C8 FD 08 | 	rdlong	muldiva_, #0
0089c 221 A1 CA BD A0 | 	mov	muldivb_, imm_1000_
008a0 222 8C 3A FD 5C | 	call	#divide_
008a4 223 D6 C8 BD A0 | 	mov	muldiva_, arg01
008a8 224 8C 3A FD 5C | 	call	#divide_
008ac 225 DD CA 3D C3 | 	cmps	muldivb_, local03 wc,wz
008b0 226             | '         return
008b0 226 A8 5E C4 80 |  if_a	add	pc, #4*(LR__0009 - ($+1))
008b4 227 50 5E FC 84 | 	sub	pc, #4*(($+1) - LR__0002)
008b8 228             | LR__0003
008b8 228             | ' 
008b8 228             | '     if _char == "#"
008b8 228 23 B6 7D 86 | 	cmp	local01, #35 wz
008bc 229 20 5E D4 80 |  if_ne	add	pc, #4*(LR__0004 - ($+1))
008c0 22a             | '       _len := meguno.rxTime(100)
008c0 22a 64 AC FD A0 | 	mov	arg01, #100
008c4 22b 14 72 FD 80 | 	add	objptr, #20
008c8 22c 33 84 FC 5C | 	call	#LMM_CALL
008cc 22d 94 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_RxTime
008d0 22e 14 72 FD 84 | 	sub	objptr, #20
008d4 22f CF BC BD A0 | 	mov	local04, result1
008d8 230             | '        if _char == -1                                     'if timeout (-1) return error (-1)
008d8 230 AF B6 3D 86 | 	cmp	local01, imm_4294967295_ wz
008dc 231             | '          return
008dc 231 7C 5E E8 80 |  if_e	add	pc, #4*(LR__0009 - ($+1))
008e0 232             | LR__0004
008e0 232             | '     cmd_len := _len
008e0 232 01 72 FD 80 | 	add	objptr, #1
008e4 233 B9 BC 3D 00 | 	wrbyte	local04, objptr
008e8 234 01 72 FD 84 | 	sub	objptr, #1
008ec 235             | ' 
008ec 235             | '       _cmdFound := true
008ec 235             | '       _time := cnt
008ec 235 F1 B9 BD A0 | 	mov	local02, cnt
008f0 236             | '       _ms := 100
008f0 236 64 BA FD A0 | 	mov	local03, #100
008f4 237             | ' 
008f4 237             | '       repeat while meguno.available < _len
008f4 237             | LR__0005
008f4 237 14 72 FD 80 | 	add	objptr, #20
008f8 238 33 84 FC 5C | 	call	#LMM_CALL
008fc 239 1C 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Available
00900 23a 14 72 FD 84 | 	sub	objptr, #20
00904 23b DE 9E 3D C1 | 	cmps	result1, local04 wc
00908 23c 28 5E CC 80 |  if_ae	add	pc, #4*(LR__0006 - ($+1))
0090c 23d             | '         if(cnt - _time) / (clkfreq / 1000) > _ms                                'time out if we don't see a full packet soon timeout
0090c 23d F1 B7 BD A0 | 	mov	local01, cnt
00910 23e DC B6 BD 84 | 	sub	local01, local02
00914 23f 00 C8 FD 08 | 	rdlong	muldiva_, #0
00918 240 A1 CA BD A0 | 	mov	muldivb_, imm_1000_
0091c 241 8C 3A FD 5C | 	call	#divide_
00920 242 DB C8 BD A0 | 	mov	muldiva_, local01
00924 243 8C 3A FD 5C | 	call	#divide_
00928 244 DD CA 3D C3 | 	cmps	muldivb_, local03 wc,wz
0092c 245             | '           return
0092c 245 2C 5E C4 80 |  if_a	add	pc, #4*(LR__0009 - ($+1))
00930 246 40 5E FC 84 | 	sub	pc, #4*(($+1) - LR__0005)
00934 247             | LR__0006
00934 247             | ' 
00934 247             | '     _cmd := meguno.rx
00934 247 14 72 FD 80 | 	add	objptr, #20
00938 248             | ' {{
00938 248             | ' }}
00938 248             | ' 
00938 248             | '   repeat while (rxByte := RxCheck) < 0                  'return the byte, wait while the buffer is empty
00938 248             | LR__0007
00938 248 33 84 FC 5C | 	call	#LMM_CALL
0093c 249 40 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_RxCheck
00940 24a 00 9E 7D C1 | 	cmps	result1, #0 wc
00944 24b 10 5E F0 84 |  if_b	sub	pc, #4*(($+1) - LR__0007)
00948 24c             | '                       'commands can be variable length, we pull just the first and leave the rest for main code to deal with
00948 24c             | '     cmd_avail := true
00948 24c 01 BC FD A4 | 	neg	local04, #1
0094c 24d 12 72 FD 84 | 	sub	objptr, #18
00950 24e B9 BC 3D 00 | 	wrbyte	local04, objptr
00954 24f 02 72 FD 84 | 	sub	objptr, #2
00958 250             | '     cmd := _cmd
00958 250 B9 9E 3D 00 | 	wrbyte	result1, objptr
0095c 251             | LR__0008
0095c 251             | '   return
0095c 251             | LR__0009
0095c 251 9F A0 BD A0 | 	mov	sp, fp
00960 252 6B EE FC 5C | 	call	#popregs_
00964 253             | _megunolink_ez_listen_ret
00964 253 3B 84 FC 5C | 	call	#LMM_RET
00968 254             | 
00968 254             | ' 
00968 254             | ' PRI intToFixed(val, places) | pos, max_neg, div, ln, idx
00968 254             | _megunolink_ez_intToFixed
00968 254 06 B8 FC A0 | 	mov	COUNT_, #6
0096c 255 5E D4 FC 5C | 	call	#pushregs_
00970 256 D6 B6 BD A0 | 	mov	local01, arg01
00974 257 D7 B8 BD A0 | 	mov	local02, arg02
00978 258 00 BA FD A0 | 	mov	local03, #0
0097c 259             | ' 
0097c 259             | '   clearStr(@temp_string)
0097c 259 03 72 FD 80 | 	add	objptr, #3
00980 25a B9 AC BD A0 | 	mov	arg01, objptr
00984 25b 03 72 FD 84 | 	sub	objptr, #3
00988 25c 33 84 FC 5C | 	call	#LMM_CALL
0098c 25d CC 0A 00 00 | 	long	@@@_megunolink_ez_clearStr
00990 25e             | '   pos := 1
00990 25e 01 AE FD A0 | 	mov	arg02, #1
00994 25f             | '   idx := 0
00994 25f 00 AC FD A0 | 	mov	arg01, #0
00998 260             | '   ln := 10
00998 260             | ' 
00998 260             | '   'this code adapted from FullDuplexSerial
00998 260             | '   max_neg := val == NEGX                                    'Check for max negative
00998 260 00 BC FD A0 | 	mov	local04, #0
0099c 261 A9 B6 3D 86 | 	cmp	local01, imm_2147483648_ wz
009a0 262 01 BC E9 A4 |  if_e	neg	local04, #1
009a4 263             | '   if val < 0
009a4 263 00 B6 7D C1 | 	cmps	local01, #0 wc
009a8 264 1C 5E CC 80 |  if_ae	add	pc, #4*(LR__0010 - ($+1))
009ac 265             | '     val := ||(val+max_neg)                                'If negative, make positive; adjust for max negative
009ac 265 DE B6 BD 80 | 	add	local01, local04
009b0 266 DB B6 BD A8 | 	abs	local01, local01
009b4 267             | '     temp_string[idx] :=("-")                                             'and output sign
009b4 267 03 72 FD 80 | 	add	objptr, #3
009b8 268 2D 9E FD A0 | 	mov	result1, #45
009bc 269 B9 9E 3D 00 | 	wrbyte	result1, objptr
009c0 26a             | '     idx++
009c0 26a 01 AC FD A0 | 	mov	arg01, #1
009c4 26b 03 72 FD 84 | 	sub	objptr, #3
009c8 26c             | LR__0010
009c8 26c             | ' 
009c8 26c             | ' 
009c8 26c             | '   div := 1_000_000_000                                    'Initialize divisor
009c8 26c A0 BE BD A0 | 	mov	local05, imm_1000000000_
009cc 26d             | ' 
009cc 26d             | '   repeat 10                                            'Loop for 10 digits
009cc 26d 0A C0 FD A0 | 	mov	local06, #10
009d0 26e 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
009d4 26f E4 00 00 00 | 	long	(@@@LR__0017-@@@LR__0011)
009d8 270             | LR__0011
009d8 270             | '     if pos == (ln - (places))             'if we are one before the decimal location
009d8 270 0A CA FD A0 | 	mov	muldivb_, #10
009dc 271 DC CA BD 84 | 	sub	muldivb_, local02
009e0 272 E5 AE 3D 86 | 	cmp	arg02, muldivb_ wz
009e4 273             | '       result~~                                         'flag non-zero found to start adding zeros, including leading zero
009e4 273 01 BA E9 A4 |  if_e	neg	local03, #1
009e8 274             | ' 
009e8 274             | '     if val => div
009e8 274 DF B6 3D C1 | 	cmps	local01, local05 wc
009ec 275 04 01 70 5C |  if_b	jmp	#LMM_FCACHE_START + (LR__0012 - LR__0011)
009f0 276             | '       temp_string[idx] := (val / div + "0" + max_neg * (div == 1)) 'If non-zero digit, output digit; adjust for max negative
009f0 276 DB C8 BD A0 | 	mov	muldiva_, local01
009f4 277 DF CA BD A0 | 	mov	muldivb_, local05
009f8 278 8C 3A FD 5C | 	call	#divide_
009fc 279 E5 BA BD A0 | 	mov	local03, muldivb_
00a00 27a 30 BA FD 80 | 	add	local03, #48
00a04 27b 00 CA FD A0 | 	mov	muldivb_, #0
00a08 27c 01 BE 7D 86 | 	cmp	local05, #1 wz
00a0c 27d 01 CA E9 A4 |  if_e	neg	muldivb_, #1
00a10 27e DE C8 BD A0 | 	mov	muldiva_, local04
00a14 27f 7D 12 FD 5C | 	call	#unsmultiply_
00a18 280 E4 BA BD 80 | 	add	local03, muldiva_
00a1c 281 D6 CA BD A0 | 	mov	muldivb_, arg01
00a20 282 03 72 FD 80 | 	add	objptr, #3
00a24 283 B9 CA BD 80 | 	add	muldivb_, objptr
00a28 284 E5 BA 3D 00 | 	wrbyte	local03, muldivb_
00a2c 285             | '       idx++
00a2c 285 01 AC FD 80 | 	add	arg01, #1
00a30 286             | '       val //= div                                       'and digit from value
00a30 286 DB C8 BD A0 | 	mov	muldiva_, local01
00a34 287 DF CA BD A0 | 	mov	muldivb_, local05
00a38 288 03 72 FD 84 | 	sub	objptr, #3
00a3c 289 8C 3A FD 5C | 	call	#divide_
00a40 28a E4 B6 BD A0 | 	mov	local01, muldiva_
00a44 28b             | '       result~~                                          'flag non-zero found
00a44 28b 01 BA FD A4 | 	neg	local03, #1
00a48 28c 0F 01 7C 5C | 	jmp	#LMM_FCACHE_START + (LR__0015 - LR__0011)
00a4c 28d             | LR__0012
00a4c 28d             | '     elseif result or div == 1
00a4c 28d 00 BA 7D 86 | 	cmp	local03, #0 wz
00a50 28e 08 01 54 5C |  if_ne	jmp	#LMM_FCACHE_START + (LR__0013 - LR__0011)
00a54 28f 01 BE 7D 86 | 	cmp	local05, #1 wz
00a58 290 0F 01 54 5C |  if_ne	jmp	#LMM_FCACHE_START + (LR__0014 - LR__0011)
00a5c 291             | LR__0013
00a5c 291             | '       temp_string[idx] := ("0")                           'If zero digit (or only digit) output it
00a5c 291 D6 9E BD A0 | 	mov	result1, arg01
00a60 292 03 72 FD 80 | 	add	objptr, #3
00a64 293 B9 9E BD 80 | 	add	result1, objptr
00a68 294 30 CA FD A0 | 	mov	muldivb_, #48
00a6c 295 CF CA 3D 00 | 	wrbyte	muldivb_, result1
00a70 296             | '       idx++
00a70 296 01 AC FD 80 | 	add	arg01, #1
00a74 297 03 72 FD 84 | 	sub	objptr, #3
00a78 298             | LR__0014
00a78 298             | LR__0015
00a78 298             | '     div /= 10                                             'Update divisor
00a78 298 DF C8 BD A0 | 	mov	muldiva_, local05
00a7c 299 0A CA FD A0 | 	mov	muldivb_, #10
00a80 29a 8C 3A FD 5C | 	call	#divide_
00a84 29b E5 BE BD A0 | 	mov	local05, muldivb_
00a88 29c             | ' 
00a88 29c             | '     if pos == (ln - (places))                            'at the decimal location
00a88 29c 0A 9E FD A0 | 	mov	result1, #10
00a8c 29d DC 9E BD 84 | 	sub	result1, local02
00a90 29e CF AE 3D 86 | 	cmp	arg02, result1 wz
00a94 29f 1E 01 54 5C |  if_ne	jmp	#LMM_FCACHE_START + (LR__0016 - LR__0011)
00a98 2a0             | '       temp_string[idx] := (".")
00a98 2a0 D6 9E BD A0 | 	mov	result1, arg01
00a9c 2a1 03 72 FD 80 | 	add	objptr, #3
00aa0 2a2 B9 9E BD 80 | 	add	result1, objptr
00aa4 2a3 2E CA FD A0 | 	mov	muldivb_, #46
00aa8 2a4 CF CA 3D 00 | 	wrbyte	muldivb_, result1
00aac 2a5             | '       idx++
00aac 2a5 01 AC FD 80 | 	add	arg01, #1
00ab0 2a6 03 72 FD 84 | 	sub	objptr, #3
00ab4 2a7             | LR__0016
00ab4 2a7             | '     pos++
00ab4 2a7 01 AE FD 80 | 	add	arg02, #1
00ab8 2a8 E7 C0 FD E4 | 	djnz	local06, #LMM_FCACHE_START + (LR__0011 - LR__0011)
00abc 2a9             | LR__0017
00abc 2a9 DD 9E BD A0 | 	mov	result1, local03
00ac0 2aa 9F A0 BD A0 | 	mov	sp, fp
00ac4 2ab 6B EE FC 5C | 	call	#popregs_
00ac8 2ac             | _megunolink_ez_intToFixed_ret
00ac8 2ac 3B 84 FC 5C | 	call	#LMM_RET
00acc 2ad             | 
00acc 2ad             | ' 
00acc 2ad             | ' PRI clearStr(ptr_string) | x, y
00acc 2ad             | _megunolink_ez_clearStr
00acc 2ad 03 B8 FC A0 | 	mov	COUNT_, #3
00ad0 2ae 5E D4 FC 5C | 	call	#pushregs_
00ad4 2af D6 B6 BD A0 | 	mov	local01, arg01
00ad8 2b0             | '   y := 0
00ad8 2b0 00 B8 FD A0 | 	mov	local02, #0
00adc 2b1             | '   x := strsize(ptr_string)
00adc 2b1 DB AC BD A0 | 	mov	arg01, local01
00ae0 2b2 33 84 FC 5C | 	call	#LMM_CALL
00ae4 2b3 28 1E 00 00 | 	long	@@@__system____builtin_strlen
00ae8 2b4             | '   repeat x
00ae8 2b4 00 9E 7D 86 | 	cmp	result1, #0 wz
00aec 2b5 20 5E E8 80 |  if_e	add	pc, #4*(LR__0020 - ($+1))
00af0 2b6 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
00af4 2b7 18 00 00 00 | 	long	(@@@LR__0019-@@@LR__0018)
00af8 2b8             | LR__0018
00af8 2b8             | '     byte[ptr_string][y++] := 0
00af8 2b8 DC AC BD A0 | 	mov	arg01, local02
00afc 2b9 DB AC BD 80 | 	add	arg01, local01
00b00 2ba 00 BA FD A0 | 	mov	local03, #0
00b04 2bb D6 BA 3D 00 | 	wrbyte	local03, arg01
00b08 2bc 01 B8 FD 80 | 	add	local02, #1
00b0c 2bd E7 9E FD E4 | 	djnz	result1, #LMM_FCACHE_START + (LR__0018 - LR__0018)
00b10 2be             | LR__0019
00b10 2be             | LR__0020
00b10 2be 9F A0 BD A0 | 	mov	sp, fp
00b14 2bf 6B EE FC 5C | 	call	#popregs_
00b18 2c0             | _megunolink_ez_clearStr_ret
00b18 2c0 3B 84 FC 5C | 	call	#LMM_RET
00b1c 2c1             | 
00b1c 2c1             | ' 
00b1c 2c1             | ' 
00b1c 2c1             | ' PUB Start(rxPin, txPin, mode, baudrate) : okay
00b1c 2c1             | _FullDuplexSerialAvail_Start
00b1c 2c1 04 B8 FC A0 | 	mov	COUNT_, #4
00b20 2c2 5E D4 FC 5C | 	call	#pushregs_
00b24 2c3 D6 B6 BD A0 | 	mov	local01, arg01
00b28 2c4 D7 B8 BD A0 | 	mov	local02, arg02
00b2c 2c5 D8 BA BD A0 | 	mov	local03, arg03
00b30 2c6 D9 BC BD A0 | 	mov	local04, arg04
00b34 2c7             | ' {{
00b34 2c7             | ' }}
00b34 2c7             | ' 
00b34 2c7             | '   Stop                                                  'make sure the driver isnt already running
00b34 2c7 33 84 FC 5C | 	call	#LMM_CALL
00b38 2c8 D4 0B 00 00 | 	long	@@@_FullDuplexSerialAvail_Stop
00b3c 2c9             | '   longfill(@rx_head, 0, 4)                              'zero out the buffer pointers
00b3c 2c9 04 72 FD 80 | 	add	objptr, #4
00b40 2ca B9 AC BD A0 | 	mov	arg01, objptr
00b44 2cb 04 72 FD 84 | 	sub	objptr, #4
00b48 2cc 00 AE FD A0 | 	mov	arg02, #0
00b4c 2cd 04 B0 FD A0 | 	mov	arg03, #4
00b50 2ce 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
00b54 2cf 0C 00 00 00 | 	long	(@@@LR__0022-@@@LR__0021)
00b58 2d0             | LR__0021
00b58 2d0 D6 AE 3D 08 | 	wrlong	arg02, arg01
00b5c 2d1 04 AC FD 80 | 	add	arg01, #4
00b60 2d2 E7 B0 FD E4 | 	djnz	arg03, #LMM_FCACHE_START + (LR__0021 - LR__0021)
00b64 2d3             | LR__0022
00b64 2d3             | '   longmove(@rx_pin, @rxpin, 3)                          'copy the start parameters to this objects pin variables
00b64 2d3 14 72 FD 80 | 	add	objptr, #20
00b68 2d4 B9 B6 3D 08 | 	wrlong	local01, objptr
00b6c 2d5 04 72 FD 80 | 	add	objptr, #4
00b70 2d6 B9 B8 3D 08 | 	wrlong	local02, objptr
00b74 2d7 04 72 FD 80 | 	add	objptr, #4
00b78 2d8 B9 BA 3D 08 | 	wrlong	local03, objptr
00b7c 2d9 1C 72 FD 84 | 	sub	objptr, #28
00b80 2da             | '   bit_ticks := clkfreq / baudrate                       'number of clock ticks per bit for the desired baudrate
00b80 2da 00 C8 FD 08 | 	rdlong	muldiva_, #0
00b84 2db DE CA BD A0 | 	mov	muldivb_, local04
00b88 2dc 8C 3A FD 5C | 	call	#divide_
00b8c 2dd 20 72 FD 80 | 	add	objptr, #32
00b90 2de B9 CA 3D 08 | 	wrlong	muldivb_, objptr
00b94 2df             | '   buffer_ptr := @rx_buffer                              'save the address of the receive buffer
00b94 2df 08 72 FD 80 | 	add	objptr, #8
00b98 2e0 B9 BC BD A0 | 	mov	local04, objptr
00b9c 2e1 04 72 FD 84 | 	sub	objptr, #4
00ba0 2e2 B9 BC 3D 08 | 	wrlong	local04, objptr
00ba4 2e3             | '   okay := cog := cognew(@entry, @rx_head) + 1           'start the new cog now, assembly cog at "entry" label.
00ba4 2e3 CC AE BD A0 | 	mov	arg02, ptr__FullDuplexSerialAvail_dat__
00ba8 2e4 20 72 FD 84 | 	sub	objptr, #32
00bac 2e5 B9 B0 BD A0 | 	mov	arg03, objptr
00bb0 2e6 04 72 FD 84 | 	sub	objptr, #4
00bb4 2e7 1E AC FD A0 | 	mov	arg01, #30
00bb8 2e8 33 84 FC 5C | 	call	#LMM_CALL
00bbc 2e9 1C 1D 00 00 | 	long	@@@__system___coginit
00bc0 2ea 01 9E FD 80 | 	add	result1, #1
00bc4 2eb B9 9E 3D 08 | 	wrlong	result1, objptr
00bc8 2ec 9F A0 BD A0 | 	mov	sp, fp
00bcc 2ed 6B EE FC 5C | 	call	#popregs_
00bd0 2ee             | _FullDuplexSerialAvail_Start_ret
00bd0 2ee 3B 84 FC 5C | 	call	#LMM_RET
00bd4 2ef             | 
00bd4 2ef             | ' 
00bd4 2ef             | ' 
00bd4 2ef             | ' PUB Stop
00bd4 2ef             | _FullDuplexSerialAvail_Stop
00bd4 2ef             | ' {{
00bd4 2ef             | ' }}
00bd4 2ef             | ' 
00bd4 2ef             | '   if cog
00bd4 2ef B9 AC BD 0A | 	rdlong	arg01, objptr wz
00bd8 2f0 14 5E E8 80 |  if_e	add	pc, #4*(LR__0023 - ($+1))
00bdc 2f1             | '     cogstop(cog~ - 1)                                   'if the driver is already running, stop the cog
00bdc 2f1 B9 AC BD 08 | 	rdlong	arg01, objptr
00be0 2f2 00 B0 FD A0 | 	mov	arg03, #0
00be4 2f3 B9 B0 3D 08 | 	wrlong	arg03, objptr
00be8 2f4 01 AC FD 84 | 	sub	arg01, #1
00bec 2f5 03 AC 7D 0C | 	cogstop	arg01
00bf0 2f6             | LR__0023
00bf0 2f6             | '   longfill(@rx_head, 0, 9)                              'zero out configuration variables
00bf0 2f6 04 72 FD 80 | 	add	objptr, #4
00bf4 2f7 B9 AC BD A0 | 	mov	arg01, objptr
00bf8 2f8 04 72 FD 84 | 	sub	objptr, #4
00bfc 2f9 00 AE FD A0 | 	mov	arg02, #0
00c00 2fa 09 B0 FD A0 | 	mov	arg03, #9
00c04 2fb 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
00c08 2fc 0C 00 00 00 | 	long	(@@@LR__0025-@@@LR__0024)
00c0c 2fd             | LR__0024
00c0c 2fd D6 AE 3D 08 | 	wrlong	arg02, arg01
00c10 2fe 04 AC FD 80 | 	add	arg01, #4
00c14 2ff E7 B0 FD E4 | 	djnz	arg03, #LMM_FCACHE_START + (LR__0024 - LR__0024)
00c18 300             | LR__0025
00c18 300             | _FullDuplexSerialAvail_Stop_ret
00c18 300 3B 84 FC 5C | 	call	#LMM_RET
00c1c 301             | 
00c1c 301             | ' 
00c1c 301             | ' PUB Available : byteCount
00c1c 301             | _FullDuplexSerialAvail_Available
00c1c 301             | ' {{
00c1c 301             | ' }}
00c1c 301             | '   byteCount := rx_head - rx_tail
00c1c 301 04 72 FD 80 | 	add	objptr, #4
00c20 302 B9 9E BD 08 | 	rdlong	result1, objptr
00c24 303 04 72 FD 80 | 	add	objptr, #4
00c28 304 B9 A2 BD 08 | 	rdlong	_var01, objptr
00c2c 305 08 72 FD 84 | 	sub	objptr, #8
00c30 306 D1 9E BD 84 | 	sub	result1, _var01
00c34 307             | ' 
00c34 307             | '   if byteCount < 0
00c34 307 00 9E 7D C1 | 	cmps	result1, #0 wc
00c38 308             | '     byteCount += BUFF_SIZE
00c38 308 10 9E F1 80 |  if_b	add	result1, #16
00c3c 309             | _FullDuplexSerialAvail_Available_ret
00c3c 309 3B 84 FC 5C | 	call	#LMM_RET
00c40 30a             | 
00c40 30a             | ' 
00c40 30a             | ' 
00c40 30a             | ' PUB RxCheck : rxByte
00c40 30a             | _FullDuplexSerialAvail_RxCheck
00c40 30a             | ' {{
00c40 30a             | ' }}
00c40 30a             | ' 
00c40 30a             | ' 
00c40 30a             | '   rxByte--                                              'make rxbyte = -1
00c40 30a 01 A2 FD A4 | 	neg	_var01, #1
00c44 30b             | '   if rx_tail <> rx_head                                 'if a byte is in the buffer, then
00c44 30b 08 72 FD 80 | 	add	objptr, #8
00c48 30c B9 9E BD 08 | 	rdlong	result1, objptr
00c4c 30d 04 72 FD 84 | 	sub	objptr, #4
00c50 30e B9 A4 BD 08 | 	rdlong	_var02, objptr
00c54 30f 04 72 FD 84 | 	sub	objptr, #4
00c58 310 D2 9E 3D 86 | 	cmp	result1, _var02 wz
00c5c 311 2C 5E E8 80 |  if_e	add	pc, #4*(LR__0026 - ($+1))
00c60 312             | '     rxByte := rx_buffer[rx_tail]                        '  grab it and store in rxByte
00c60 312 08 72 FD 80 | 	add	objptr, #8
00c64 313 B9 A4 BD 08 | 	rdlong	_var02, objptr
00c68 314 D2 A2 BD A0 | 	mov	_var01, _var02
00c6c 315 20 72 FD 80 | 	add	objptr, #32
00c70 316 B9 A2 BD 80 | 	add	_var01, objptr
00c74 317 D1 A2 BD 00 | 	rdbyte	_var01, _var01
00c78 318             | '     rx_tail := (rx_tail + 1) & $F                       '  advance the buffer pointer
00c78 318 01 A4 FD 80 | 	add	_var02, #1
00c7c 319 0F A4 FD 60 | 	and	_var02, #15
00c80 31a 20 72 FD 84 | 	sub	objptr, #32
00c84 31b B9 A4 3D 08 | 	wrlong	_var02, objptr
00c88 31c 08 72 FD 84 | 	sub	objptr, #8
00c8c 31d             | LR__0026
00c8c 31d D1 9E BD A0 | 	mov	result1, _var01
00c90 31e             | _FullDuplexSerialAvail_RxCheck_ret
00c90 31e 3B 84 FC 5C | 	call	#LMM_RET
00c94 31f             | 
00c94 31f             | ' 
00c94 31f             | ' 
00c94 31f             | ' PUB RxTime(ms) : rxByte | t
00c94 31f             | _FullDuplexSerialAvail_RxTime
00c94 31f 03 B8 FC A0 | 	mov	COUNT_, #3
00c98 320 5E D4 FC 5C | 	call	#pushregs_
00c9c 321             | ' {{
00c9c 321             | ' }}
00c9c 321             | ' 
00c9c 321             | '   t := cnt                                              'take note of the current time
00c9c 321 F1 B7 BD A0 | 	mov	local01, cnt
00ca0 322             | '   repeat until (rxByte := RxCheck) => 0 or (cnt - t) / (clkfreq / 1000) > ms
00ca0 322             | LR__0027
00ca0 322 33 84 FC 5C | 	call	#LMM_CALL
00ca4 323 40 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_RxCheck
00ca8 324 CF B8 BD A0 | 	mov	local02, result1
00cac 325 00 B8 7D C1 | 	cmps	local02, #0 wc
00cb0 326 24 5E CC 80 |  if_ae	add	pc, #4*(LR__0028 - ($+1))
00cb4 327 F1 BB BD A0 | 	mov	local03, cnt
00cb8 328 DB BA BD 84 | 	sub	local03, local01
00cbc 329 00 C8 FD 08 | 	rdlong	muldiva_, #0
00cc0 32a A1 CA BD A0 | 	mov	muldivb_, imm_1000_
00cc4 32b 8C 3A FD 5C | 	call	#divide_
00cc8 32c DD C8 BD A0 | 	mov	muldiva_, local03
00ccc 32d 8C 3A FD 5C | 	call	#divide_
00cd0 32e D6 CA 3D C3 | 	cmps	muldivb_, arg01 wc,wz
00cd4 32f 38 5E F8 84 |  if_be	sub	pc, #4*(($+1) - LR__0027)
00cd8 330             | LR__0028
00cd8 330 DC 9E BD A0 | 	mov	result1, local02
00cdc 331 9F A0 BD A0 | 	mov	sp, fp
00ce0 332 6B EE FC 5C | 	call	#popregs_
00ce4 333             | _FullDuplexSerialAvail_RxTime_ret
00ce4 333 3B 84 FC 5C | 	call	#LMM_RET
00ce8 334             | 
00ce8 334             | ' 
00ce8 334             | ' 
00ce8 334             | ' PUB Tx(txByte)
00ce8 334             | _FullDuplexSerialAvail_Tx
00ce8 334 01 B8 FC A0 | 	mov	COUNT_, #1
00cec 335 5E D4 FC 5C | 	call	#pushregs_
00cf0 336 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
00cf4 337 24 00 00 00 | 	long	(@@@LR__0030-@@@LR__0029)
00cf8 338             | ' {{
00cf8 338             | ' }}
00cf8 338             | ' 
00cf8 338             | '   repeat until (tx_tail <> (tx_head + 1) & $F)          'wait until the buffer has room
00cf8 338             | LR__0029
00cf8 338 0C 72 FD 80 | 	add	objptr, #12
00cfc 339 B9 9E BD 08 | 	rdlong	result1, objptr
00d00 33a 01 9E FD 80 | 	add	result1, #1
00d04 33b 0F 9E FD 60 | 	and	result1, #15
00d08 33c 04 72 FD 80 | 	add	objptr, #4
00d0c 33d B9 B6 BD 08 | 	rdlong	local01, objptr
00d10 33e 10 72 FD 84 | 	sub	objptr, #16
00d14 33f CF B6 3D 86 | 	cmp	local01, result1 wz
00d18 340 E7 00 68 5C |  if_e	jmp	#LMM_FCACHE_START + (LR__0029 - LR__0029)
00d1c 341             | LR__0030
00d1c 341             | '   tx_buffer[tx_head] := txByte                          'place the byte into the buffer
00d1c 341 0C 72 FD 80 | 	add	objptr, #12
00d20 342 B9 B6 BD 08 | 	rdlong	local01, objptr
00d24 343 2C 72 FD 80 | 	add	objptr, #44
00d28 344 B9 B6 BD 80 | 	add	local01, objptr
00d2c 345 DB AC 3D 00 | 	wrbyte	arg01, local01
00d30 346             | '   tx_head := (tx_head + 1) & $F                         'advance the buffer's pointer
00d30 346 2C 72 FD 84 | 	sub	objptr, #44
00d34 347 B9 B6 BD 08 | 	rdlong	local01, objptr
00d38 348 01 B6 FD 80 | 	add	local01, #1
00d3c 349 0F B6 FD 60 | 	and	local01, #15
00d40 34a B9 B6 3D 08 | 	wrlong	local01, objptr
00d44 34b             | ' 
00d44 34b             | '   if rxtx_mode & %1000                                  'if ignoring rx echo
00d44 34b 10 72 FD 80 | 	add	objptr, #16
00d48 34c B9 B6 BD 08 | 	rdlong	local01, objptr
00d4c 34d 1C 72 FD 84 | 	sub	objptr, #28
00d50 34e 08 B6 7D 62 | 	test	local01, #8 wz
00d54 34f             | '     Rx                                                  '   receive the echoed byte and discard
00d54 34f 10 5E E8 80 |  if_e	add	pc, #4*(LR__0032 - ($+1))
00d58 350             | ' {{
00d58 350             | ' }}
00d58 350             | ' 
00d58 350             | '   repeat while (rxByte := RxCheck) < 0                  'return the byte, wait while the buffer is empty
00d58 350             | LR__0031
00d58 350 33 84 FC 5C | 	call	#LMM_CALL
00d5c 351 40 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_RxCheck
00d60 352 00 9E 7D C1 | 	cmps	result1, #0 wc
00d64 353 10 5E F0 84 |  if_b	sub	pc, #4*(($+1) - LR__0031)
00d68 354             | LR__0032
00d68 354 9F A0 BD A0 | 	mov	sp, fp
00d6c 355 6B EE FC 5C | 	call	#popregs_
00d70 356             | _FullDuplexSerialAvail_Tx_ret
00d70 356 3B 84 FC 5C | 	call	#LMM_RET
00d74 357             | 
00d74 357             | ' 
00d74 357             | ' 
00d74 357             | ' PUB Str(stringPtr)
00d74 357             | _FullDuplexSerialAvail_Str
00d74 357 02 B8 FC A0 | 	mov	COUNT_, #2
00d78 358 5E D4 FC 5C | 	call	#pushregs_
00d7c 359             | ' {{
00d7c 359             | ' }}
00d7c 359             | ' 
00d7c 359             | '   repeat strsize(stringPtr)
00d7c 359 D6 B6 BD A0 | 	mov	local01, arg01
00d80 35a 33 84 FC 5C | 	call	#LMM_CALL
00d84 35b 28 1E 00 00 | 	long	@@@__system____builtin_strlen
00d88 35c CF B8 BD A2 | 	mov	local02, result1 wz
00d8c 35d 18 5E E8 80 |  if_e	add	pc, #4*(LR__0034 - ($+1))
00d90 35e             | LR__0033
00d90 35e             | '     Tx(byte[stringPtr++])                                                       'Transmit each byte in the string
00d90 35e DB AC BD 00 | 	rdbyte	arg01, local01
00d94 35f 33 84 FC 5C | 	call	#LMM_CALL
00d98 360 E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
00d9c 361 01 B6 FD 80 | 	add	local01, #1
00da0 362 39 B8 FD E4 | 	djnz	local02, #LMM_JUMP
00da4 363 90 0D 00 00 | 	long	@@@LR__0033
00da8 364             | LR__0034
00da8 364 9F A0 BD A0 | 	mov	sp, fp
00dac 365 6B EE FC 5C | 	call	#popregs_
00db0 366             | _FullDuplexSerialAvail_Str_ret
00db0 366 3B 84 FC 5C | 	call	#LMM_RET
00db4 367             | 
00db4 367             | ' 
00db4 367             | ' 
00db4 367             | ' PUB Dec(value) | i, x
00db4 367             | _FullDuplexSerialAvail_Dec
00db4 367 05 B8 FC A0 | 	mov	COUNT_, #5
00db8 368 5E D4 FC 5C | 	call	#pushregs_
00dbc 369 D6 B6 BD A0 | 	mov	local01, arg01
00dc0 36a 00 B8 FD A0 | 	mov	local02, #0
00dc4 36b             | ' {{
00dc4 36b             | ' }}
00dc4 36b             | ' 
00dc4 36b             | '   x := value == NEGX                                    'Check for max negative
00dc4 36b 00 BA FD A0 | 	mov	local03, #0
00dc8 36c A9 B6 3D 86 | 	cmp	local01, imm_2147483648_ wz
00dcc 36d 01 BA E9 A4 |  if_e	neg	local03, #1
00dd0 36e             | '   if value < 0
00dd0 36e 00 B6 7D C1 | 	cmps	local01, #0 wc
00dd4 36f 14 5E CC 80 |  if_ae	add	pc, #4*(LR__0035 - ($+1))
00dd8 370             | '     value := ||(value+x)                                'If negative, make positive; adjust for max negative
00dd8 370 DD B6 BD 80 | 	add	local01, local03
00ddc 371 DB B6 BD A8 | 	abs	local01, local01
00de0 372             | '     Tx("-")                                             'and output sign
00de0 372 2D AC FD A0 | 	mov	arg01, #45
00de4 373 33 84 FC 5C | 	call	#LMM_CALL
00de8 374 E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
00dec 375             | LR__0035
00dec 375             | ' 
00dec 375             | '   i := 1_000_000_000                                    'Initialize divisor
00dec 375 A0 BC BD A0 | 	mov	local04, imm_1000000000_
00df0 376             | ' 
00df0 376             | '   repeat 10                                             'Loop for 10 digits
00df0 376 0A BE FD A0 | 	mov	local05, #10
00df4 377             | LR__0036
00df4 377             | '     if value => i
00df4 377 DE B6 3D C1 | 	cmps	local01, local04 wc
00df8 378 4C 5E F0 80 |  if_b	add	pc, #4*(LR__0037 - ($+1))
00dfc 379             | '       Tx(value / i + "0" + x*(i == 1))                  'If non-zero digit, output digit; adjust for max negative
00dfc 379 DB C8 BD A0 | 	mov	muldiva_, local01
00e00 37a DE CA BD A0 | 	mov	muldivb_, local04
00e04 37b 8C 3A FD 5C | 	call	#divide_
00e08 37c E5 AC BD A0 | 	mov	arg01, muldivb_
00e0c 37d 30 AC FD 80 | 	add	arg01, #48
00e10 37e 00 CA FD A0 | 	mov	muldivb_, #0
00e14 37f 01 BC 7D 86 | 	cmp	local04, #1 wz
00e18 380 01 CA E9 A4 |  if_e	neg	muldivb_, #1
00e1c 381 DD C8 BD A0 | 	mov	muldiva_, local03
00e20 382 7D 12 FD 5C | 	call	#unsmultiply_
00e24 383 E4 AC BD 80 | 	add	arg01, muldiva_
00e28 384 33 84 FC 5C | 	call	#LMM_CALL
00e2c 385 E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
00e30 386             | '       value //= i                                       'and digit from value
00e30 386 DB C8 BD A0 | 	mov	muldiva_, local01
00e34 387 DE CA BD A0 | 	mov	muldivb_, local04
00e38 388 8C 3A FD 5C | 	call	#divide_
00e3c 389 E4 B6 BD A0 | 	mov	local01, muldiva_
00e40 38a             | '       result~~                                          'flag non-zero found
00e40 38a 01 B8 FD A4 | 	neg	local02, #1
00e44 38b 1C 5E FC 80 | 	add	pc, #4*(LR__0040 - ($+1))
00e48 38c             | LR__0037
00e48 38c             | '     elseif result or i == 1
00e48 38c 00 B8 7D 86 | 	cmp	local02, #0 wz
00e4c 38d 08 5E D4 80 |  if_ne	add	pc, #4*(LR__0038 - ($+1))
00e50 38e 01 BC 7D 86 | 	cmp	local04, #1 wz
00e54 38f 0C 5E D4 80 |  if_ne	add	pc, #4*(LR__0039 - ($+1))
00e58 390             | LR__0038
00e58 390             | '       Tx("0")                                           'If zero digit (or only digit) output it
00e58 390 30 AC FD A0 | 	mov	arg01, #48
00e5c 391 33 84 FC 5C | 	call	#LMM_CALL
00e60 392 E8 0C 00 00 | 	long	@@@_FullDuplexSerialAvail_Tx
00e64 393             | LR__0039
00e64 393             | LR__0040
00e64 393             | '     i /= 10                                             'Update divisor
00e64 393 DE C8 BD A0 | 	mov	muldiva_, local04
00e68 394 0A CA FD A0 | 	mov	muldivb_, #10
00e6c 395 8C 3A FD 5C | 	call	#divide_
00e70 396 E5 BC BD A0 | 	mov	local04, muldivb_
00e74 397 01 BE FD 86 | 	sub	local05, #1 wz
00e78 398 88 5E D4 84 |  if_ne	sub	pc, #4*(($+1) - LR__0036)
00e7c 399 DC 9E BD A0 | 	mov	result1, local02
00e80 39a 9F A0 BD A0 | 	mov	sp, fp
00e84 39b 6B EE FC 5C | 	call	#popregs_
00e88 39c             | _FullDuplexSerialAvail_Dec_ret
00e88 39c 3B 84 FC 5C | 	call	#LMM_RET
00e8c 39d             | 
00e8c 39d             | ' 
00e8c 39d             | '   
00e8c 39d             | ' PUB Config(SymAddr)
00e8c 39d             | _Numbers_Config
00e8c 39d             | ' {{Configure for custom symbols.
00e8c 39d             | '               (default is '%').}}  
00e8c 39d             | '   bytemove(@Symbols, SymAddr, 7)        
00e8c 39d 10 72 FD 80 | 	add	objptr, #16
00e90 39e D6 AE BD A0 | 	mov	arg02, arg01
00e94 39f B9 AC BD A0 | 	mov	arg01, objptr
00e98 3a0 07 B0 FD A0 | 	mov	arg03, #7
00e9c 3a1 10 72 FD 84 | 	sub	objptr, #16
00ea0 3a2 33 84 FC 5C | 	call	#LMM_CALL
00ea4 3a3 48 1D 00 00 | 	long	@@@__system____builtin_memmove
00ea8 3a4             | _Numbers_Config_ret
00ea8 3a4 3B 84 FC 5C | 	call	#LMM_RET
00eac 3a5             | 
00eac 3a5             | ' 
00eac 3a5             | ' 
00eac 3a5             | ' PUB FloatToString(Single) : StringPtr
00eac 3a5             | _FloatString_FloatToString
00eac 3a5 09 B8 FC A0 | 	mov	COUNT_, #9
00eb0 3a6 5E D4 FC 5C | 	call	#pushregs_
00eb4 3a7             | ' 
00eb4 3a7             | ' ''Convert floating-point number to string
00eb4 3a7             | ' ''
00eb4 3a7             | ' ''  entry:
00eb4 3a7             | ' ''      Single = floating-point number
00eb4 3a7             | ' ''
00eb4 3a7             | ' ''  exit:
00eb4 3a7             | ' ''      StringPtr = pointer to resultant z-string
00eb4 3a7             | ' ''
00eb4 3a7             | ' ''  Magnitudes below 1e+12 and within 1e-12 will be expressed directly;
00eb4 3a7             | ' ''  otherwise, scientific notation will be used.
00eb4 3a7             | ' ''
00eb4 3a7             | ' ''  examples                 results
00eb4 3a7             | ' ''  -----------------------------------------
00eb4 3a7             | ' ''  FloatToString(0.0)       "0"
00eb4 3a7             | ' ''  FloatToString(1.0)       "1"
00eb4 3a7             | ' ''  FloatToString(-1.0)      "-1"
00eb4 3a7             | ' ''  FloatToString(^^2.0)     "1.414214"
00eb4 3a7             | ' ''  FloatToString(2.34e-3)   "0.00234"
00eb4 3a7             | ' ''  FloatToString(-1.5e-5)   "-0.000015"
00eb4 3a7             | ' ''  FloatToString(2.7e+6)    "2700000"
00eb4 3a7             | ' ''  FloatToString(1e11)      "100000000000"
00eb4 3a7             | ' ''  FloatToString(1e12)      "1.000000e+12"
00eb4 3a7             | ' ''  FloatToString(1e-12)     "0.000000000001"
00eb4 3a7             | ' ''  FloatToString(1e-13)     "1.000000e-13"
00eb4 3a7             | ' 
00eb4 3a7             | '   'perform initial setup
00eb4 3a7             | '   StringPtr := Setup(Single)
00eb4 3a7 D6 B6 BD A0 | 	mov	local01, arg01
00eb8 3a8 33 84 FC 5C | 	call	#LMM_CALL
00ebc 3a9 10 10 00 00 | 	long	@@@_FloatString_Setup
00ec0 3aa CF B8 BD A0 | 	mov	local02, result1
00ec4 3ab             | ' 
00ec4 3ab             | '   'eliminate trailing zeros
00ec4 3ab             | '   if integer
00ec4 3ab 0C 72 FD 80 | 	add	objptr, #12
00ec8 3ac B9 9E BD 0A | 	rdlong	result1, objptr wz
00ecc 3ad 0C 72 FD 84 | 	sub	objptr, #12
00ed0 3ae 6C 5E E8 80 |  if_e	add	pc, #4*(LR__0042 - ($+1))
00ed4 3af             | '     repeat until integer // 10
00ed4 3af             | LR__0041
00ed4 3af 0C 72 FD 80 | 	add	objptr, #12
00ed8 3b0 B9 C8 BD 08 | 	rdlong	muldiva_, objptr
00edc 3b1 0C 72 FD 84 | 	sub	objptr, #12
00ee0 3b2 0A CA FD A0 | 	mov	muldivb_, #10
00ee4 3b3 8C 3A FD 5C | 	call	#divide_
00ee8 3b4 00 C8 7D 86 | 	cmp	muldiva_, #0 wz
00eec 3b5 60 5E D4 80 |  if_ne	add	pc, #4*(LR__0043 - ($+1))
00ef0 3b6             | '       integer /= 10
00ef0 3b6 0C 72 FD 80 | 	add	objptr, #12
00ef4 3b7 B9 C8 BD 08 | 	rdlong	muldiva_, objptr
00ef8 3b8 0C 72 FD 84 | 	sub	objptr, #12
00efc 3b9 0A CA FD A0 | 	mov	muldivb_, #10
00f00 3ba 8C 3A FD 5C | 	call	#divide_
00f04 3bb 0C 72 FD 80 | 	add	objptr, #12
00f08 3bc B9 CA 3D 08 | 	wrlong	muldivb_, objptr
00f0c 3bd             | '       tens /= 10
00f0c 3bd 04 72 FD 80 | 	add	objptr, #4
00f10 3be B9 C8 BD 08 | 	rdlong	muldiva_, objptr
00f14 3bf 10 72 FD 84 | 	sub	objptr, #16
00f18 3c0 0A CA FD A0 | 	mov	muldivb_, #10
00f1c 3c1 8C 3A FD 5C | 	call	#divide_
00f20 3c2 10 72 FD 80 | 	add	objptr, #16
00f24 3c3 B9 CA 3D 08 | 	wrlong	muldivb_, objptr
00f28 3c4             | '       digits--
00f28 3c4 0C 72 FD 84 | 	sub	objptr, #12
00f2c 3c5 B9 CA BD 08 | 	rdlong	muldivb_, objptr
00f30 3c6 01 CA FD 84 | 	sub	muldivb_, #1
00f34 3c7 B9 CA 3D 08 | 	wrlong	muldivb_, objptr
00f38 3c8 04 72 FD 84 | 	sub	objptr, #4
00f3c 3c9 6C 5E FC 84 | 	sub	pc, #4*(($+1) - LR__0041)
00f40 3ca             | '   else
00f40 3ca             | LR__0042
00f40 3ca             | '     digits~
00f40 3ca 00 9E FD A0 | 	mov	result1, #0
00f44 3cb 04 72 FD 80 | 	add	objptr, #4
00f48 3cc B9 9E 3D 08 | 	wrlong	result1, objptr
00f4c 3cd 04 72 FD 84 | 	sub	objptr, #4
00f50 3ce             | LR__0043
00f50 3ce             | ' 
00f50 3ce             | '   'express number according to exponent
00f50 3ce             | '   case exponent
00f50 3ce 08 72 FD 80 | 	add	objptr, #8
00f54 3cf B9 BA BD 08 | 	rdlong	local03, objptr
00f58 3d0 08 72 FD 84 | 	sub	objptr, #8
00f5c 3d1 00 BA 7D C1 | 	cmps	local03, #0 wc
00f60 3d2 08 5E F0 80 |  if_b	add	pc, #4*(LR__0044 - ($+1))
00f64 3d3 0C BA 7D C1 | 	cmps	local03, #12 wc
00f68 3d4 3C 5E F0 80 |  if_b	add	pc, #4*(LR__0045 - ($+1))
00f6c 3d5             | LR__0044
00f6c 3d5 04 72 FD 80 | 	add	objptr, #4
00f70 3d6 B9 BC BD 08 | 	rdlong	local04, objptr
00f74 3d7 04 72 FD 84 | 	sub	objptr, #4
00f78 3d8 DE BE BD A0 | 	mov	local05, local04
00f7c 3d9 0D BE FD 84 | 	sub	local05, #13
00f80 3da 01 C0 FD A4 | 	neg	local06, #1
00f84 3db 01 C2 FD A4 | 	neg	local07, #1
00f88 3dc DF C4 BD A0 | 	mov	local08, local05
00f8c 3dd E2 C6 BD A0 | 	mov	local09, local08
00f90 3de E3 C0 BD 44 | 	maxs	local06, local09
00f94 3df AF C4 BD 40 | 	mins	local08, imm_4294967295_
00f98 3e0 DD C0 3D C3 | 	cmps	local06, local03 wc,wz
00f9c 3e1 E2 BA 39 C3 |  if_be	cmps	local03, local08 wc,wz
00fa0 3e2 20 5E F8 80 |  if_be	add	pc, #4*(LR__0046 - ($+1))
00fa4 3e3 44 5E FC 80 | 	add	pc, #4*(LR__0047 - ($+1))
00fa8 3e4             | LR__0045
00fa8 3e4             | '     'in range left of decimal
00fa8 3e4             | '     11..0:
00fa8 3e4             | '       AddDigits(exponent + 1)
00fa8 3e4 08 72 FD 80 | 	add	objptr, #8
00fac 3e5 B9 AC BD 08 | 	rdlong	arg01, objptr
00fb0 3e6 08 72 FD 84 | 	sub	objptr, #8
00fb4 3e7 01 AC FD 80 | 	add	arg01, #1
00fb8 3e8 33 84 FC 5C | 	call	#LMM_CALL
00fbc 3e9 9C 13 00 00 | 	long	@@@_FloatString_AddDigits
00fc0 3ea 30 5E FC 80 | 	add	pc, #4*(LR__0048 - ($+1))
00fc4 3eb             | LR__0046
00fc4 3eb             | '     'in range right of decimal
00fc4 3eb             | '     -1..digits - 13:
00fc4 3eb             | '       zeros := -exponent
00fc4 3eb 08 72 FD 80 | 	add	objptr, #8
00fc8 3ec B9 BE BD 08 | 	rdlong	local05, objptr
00fcc 3ed DF BE BD A4 | 	neg	local05, local05
00fd0 3ee 0C 72 FD 80 | 	add	objptr, #12
00fd4 3ef B9 BE 3D 08 | 	wrlong	local05, objptr
00fd8 3f0 14 72 FD 84 | 	sub	objptr, #20
00fdc 3f1             | '       AddDigits(1)
00fdc 3f1 01 AC FD A0 | 	mov	arg01, #1
00fe0 3f2 33 84 FC 5C | 	call	#LMM_CALL
00fe4 3f3 9C 13 00 00 | 	long	@@@_FloatString_AddDigits
00fe8 3f4 08 5E FC 80 | 	add	pc, #4*(LR__0048 - ($+1))
00fec 3f5             | LR__0047
00fec 3f5             | '     'out of range, do scientific notation
00fec 3f5             | '     other:
00fec 3f5             | '       DoScientific
00fec 3f5 33 84 FC 5C | 	call	#LMM_CALL
00ff0 3f6 94 12 00 00 | 	long	@@@_FloatString_DoScientific
00ff4 3f7             | LR__0048
00ff4 3f7             | ' 
00ff4 3f7             | '   'terminate z-string
00ff4 3f7             | '   byte[p]~
00ff4 3f7 B9 BE BD 08 | 	rdlong	local05, objptr
00ff8 3f8 00 BC FD A0 | 	mov	local04, #0
00ffc 3f9 DF BC 3D 00 | 	wrbyte	local04, local05
01000 3fa DC 9E BD A0 | 	mov	result1, local02
01004 3fb 9F A0 BD A0 | 	mov	sp, fp
01008 3fc 6B EE FC 5C | 	call	#popregs_
0100c 3fd             | _FloatString_FloatToString_ret
0100c 3fd 3B 84 FC 5C | 	call	#LMM_RET
01010 3fe             | 
01010 3fe             | '   
01010 3fe             | ' 
01010 3fe             | ' PRI Setup(single) : stringptr
01010 3fe             | _FloatString_Setup
01010 3fe 07 B8 FC A0 | 	mov	COUNT_, #7
01014 3ff 5E D4 FC 5C | 	call	#pushregs_
01018 400 D6 B6 BD A0 | 	mov	local01, arg01
0101c 401 00 B8 FD A0 | 	mov	local02, #0
01020 402             | ' 
01020 402             | '  'limit digits to 1..7
01020 402             | '   if precision
01020 402 18 72 FD 80 | 	add	objptr, #24
01024 403 B9 9E BD 0A | 	rdlong	result1, objptr wz
01028 404 18 72 FD 84 | 	sub	objptr, #24
0102c 405 20 5E E8 80 |  if_e	add	pc, #4*(LR__0049 - ($+1))
01030 406             | '     digits := precision #> 1 <# 7
01030 406 18 72 FD 80 | 	add	objptr, #24
01034 407 B9 9E BD 08 | 	rdlong	result1, objptr
01038 408 01 9E FD 40 | 	mins	result1, #1
0103c 409 07 9E FD 44 | 	maxs	result1, #7
01040 40a 14 72 FD 84 | 	sub	objptr, #20
01044 40b B9 9E 3D 08 | 	wrlong	result1, objptr
01048 40c 04 72 FD 84 | 	sub	objptr, #4
0104c 40d             | '   else
0104c 40d 10 5E FC 80 | 	add	pc, #4*(LR__0050 - ($+1))
01050 40e             | LR__0049
01050 40e             | '     digits := 7
01050 40e 07 9E FD A0 | 	mov	result1, #7
01054 40f 04 72 FD 80 | 	add	objptr, #4
01058 410 B9 9E 3D 08 | 	wrlong	result1, objptr
0105c 411 04 72 FD 84 | 	sub	objptr, #4
01060 412             | LR__0050
01060 412             | ' 
01060 412             | '   'initialize string pointer
01060 412             | '   p := @float_string
01060 412 2C 72 FD 80 | 	add	objptr, #44
01064 413 B9 9E BD A0 | 	mov	result1, objptr
01068 414 2C 72 FD 84 | 	sub	objptr, #44
0106c 415 B9 9E 3D 08 | 	wrlong	result1, objptr
01070 416             | ' 
01070 416             | '   'add "-" if negative
01070 416             | '   if single & $80000000
01070 416 A9 B6 3D 62 | 	test	local01, imm_2147483648_ wz
01074 417 1C 5E E8 80 |  if_e	add	pc, #4*(LR__0051 - ($+1))
01078 418             | '     byte[p++] := "-"
01078 418 B9 9E BD 08 | 	rdlong	result1, objptr
0107c 419 CF BA BD A0 | 	mov	local03, result1
01080 41a 01 BA FD 80 | 	add	local03, #1
01084 41b B9 BA 3D 08 | 	wrlong	local03, objptr
01088 41c 2D BC FD A0 | 	mov	local04, #45
0108c 41d CF BC 3D 00 | 	wrbyte	local04, result1
01090 41e 30 5E FC 80 | 	add	pc, #4*(LR__0053 - ($+1))
01094 41f             | LR__0051
01094 41f             | '   'otherwise, add any positive lead character
01094 41f             | '   elseif positive_chr
01094 41f 1C 72 FD 80 | 	add	objptr, #28
01098 420 B9 9E BD 0A | 	rdlong	result1, objptr wz
0109c 421 1C 72 FD 84 | 	sub	objptr, #28
010a0 422 20 5E E8 80 |  if_e	add	pc, #4*(LR__0052 - ($+1))
010a4 423             | '     byte[p++] := positive_chr
010a4 423 B9 9E BD 08 | 	rdlong	result1, objptr
010a8 424 CF BA BD A0 | 	mov	local03, result1
010ac 425 01 BA FD 80 | 	add	local03, #1
010b0 426 B9 BA 3D 08 | 	wrlong	local03, objptr
010b4 427 1C 72 FD 80 | 	add	objptr, #28
010b8 428 B9 BC BD 08 | 	rdlong	local04, objptr
010bc 429 1C 72 FD 84 | 	sub	objptr, #28
010c0 42a CF BC 3D 00 | 	wrbyte	local04, result1
010c4 42b             | LR__0052
010c4 42b             | LR__0053
010c4 42b             | ' 
010c4 42b             | '   'clear sign and check for 0
010c4 42b             | '   if single &= $7FFFFFFF
010c4 42b A8 B6 BD 60 | 	and	local01, imm_2147483647_
010c8 42c DB BE BD A2 | 	mov	local05, local01 wz
010cc 42d DF B6 BD A0 | 	mov	local01, local05
010d0 42e 5C 5F E8 80 |  if_e	add	pc, #4*(LR__0058 - ($+1))
010d4 42f             | ' 
010d4 42f             | '     'not 0, estimate exponent
010d4 42f             | '     exponent := ((single << 1 >> 24 - 127) * 77) ~> 8
010d4 42f DB C8 BD A0 | 	mov	muldiva_, local01
010d8 430 01 C8 FD 2C | 	shl	muldiva_, #1
010dc 431 18 C8 FD 28 | 	shr	muldiva_, #24
010e0 432 7F C8 FD 84 | 	sub	muldiva_, #127
010e4 433 4D CA FD A0 | 	mov	muldivb_, #77
010e8 434 7D 12 FD 5C | 	call	#unsmultiply_
010ec 435 E4 C0 BD A0 | 	mov	local06, muldiva_
010f0 436 08 C0 FD 38 | 	sar	local06, #8
010f4 437 08 72 FD 80 | 	add	objptr, #8
010f8 438 B9 C0 3D 08 | 	wrlong	local06, objptr
010fc 439             | '     
010fc 439             | '     'if very small, bias up
010fc 439             | '     if exponent < -32
010fc 439 08 72 FD 84 | 	sub	objptr, #8
01100 43a AD C0 3D C1 | 	cmps	local06, imm_4294967264_ wc
01104 43b 2C 5E CC 80 |  if_ae	add	pc, #4*(LR__0054 - ($+1))
01108 43c             | '       single := F.FMul(single, 1e13)
01108 43c DB AC BD A0 | 	mov	arg01, local01
0110c 43d A6 AE BD A0 | 	mov	arg02, imm_1427211495_
01110 43e 33 84 FC 5C | 	call	#LMM_CALL
01114 43f E0 15 00 00 | 	long	@@@_FloatMath_FMul
01118 440 CF B6 BD A0 | 	mov	local01, result1
0111c 441             | '       exponent += result := 13
0111c 441 0D B8 FD A0 | 	mov	local02, #13
01120 442 08 72 FD 80 | 	add	objptr, #8
01124 443 B9 C0 BD 08 | 	rdlong	local06, objptr
01128 444 0D C0 FD 80 | 	add	local06, #13
0112c 445 B9 C0 3D 08 | 	wrlong	local06, objptr
01130 446 08 72 FD 84 | 	sub	objptr, #8
01134 447             | LR__0054
01134 447             | '       
01134 447             | '     'determine exact exponent and integer
01134 447             | '     repeat
01134 447             | LR__0055
01134 447             | '       integer := F.FRound(F.FMul(single, tenf[exponent - digits + 1]))
01134 447 08 72 FD 80 | 	add	objptr, #8
01138 448 B9 C0 BD 08 | 	rdlong	local06, objptr
0113c 449 04 72 FD 84 | 	sub	objptr, #4
01140 44a B9 BE BD 08 | 	rdlong	local05, objptr
01144 44b 04 72 FD 84 | 	sub	objptr, #4
01148 44c DF C0 BD 84 | 	sub	local06, local05
0114c 44d 01 C0 FD 80 | 	add	local06, #1
01150 44e 02 C0 FD 2C | 	shl	local06, #2
01154 44f 98 96 FD 80 | 	add	ptr__FloatString_dat__, #152
01158 450 CB C0 BD 80 | 	add	local06, ptr__FloatString_dat__
0115c 451 E0 AE BD 08 | 	rdlong	arg02, local06
01160 452 DB AC BD A0 | 	mov	arg01, local01
01164 453 98 96 FD 84 | 	sub	ptr__FloatString_dat__, #152
01168 454 33 84 FC 5C | 	call	#LMM_CALL
0116c 455 E0 15 00 00 | 	long	@@@_FloatMath_FMul
01170 456 CF AC BD A0 | 	mov	arg01, result1
01174 457             | ' 
01174 457             | ' ''Convert float to rounded integer
01174 457             | ' 
01174 457             | '   return FInteger(single, 1)    'use 1/2 to round
01174 457 01 AE FD A0 | 	mov	arg02, #1
01178 458 33 84 FC 5C | 	call	#LMM_CALL
0117c 459 B4 16 00 00 | 	long	@@@_FloatMath_FInteger
01180 45a 0C 72 FD 80 | 	add	objptr, #12
01184 45b B9 9E 3D 08 | 	wrlong	result1, objptr
01188 45c             | '       if integer < teni[digits - 1]
01188 45c 08 72 FD 84 | 	sub	objptr, #8
0118c 45d B9 BC BD 08 | 	rdlong	local04, objptr
01190 45e 01 BC FD 84 | 	sub	local04, #1
01194 45f 02 BC FD 2C | 	shl	local04, #2
01198 460 34 97 FD 80 | 	add	ptr__FloatString_dat__, #308
0119c 461 CB BC BD 80 | 	add	local04, ptr__FloatString_dat__
011a0 462 CF C2 BD A0 | 	mov	local07, result1
011a4 463 04 72 FD 84 | 	sub	objptr, #4
011a8 464 DE C0 BD 08 | 	rdlong	local06, local04
011ac 465 E0 C2 3D C1 | 	cmps	local07, local06 wc
011b0 466 34 97 FD 84 | 	sub	ptr__FloatString_dat__, #308
011b4 467 18 5E CC 80 |  if_ae	add	pc, #4*(LR__0056 - ($+1))
011b8 468             | '         exponent--
011b8 468 08 72 FD 80 | 	add	objptr, #8
011bc 469 B9 BC BD 08 | 	rdlong	local04, objptr
011c0 46a 01 BC FD 84 | 	sub	local04, #1
011c4 46b B9 BC 3D 08 | 	wrlong	local04, objptr
011c8 46c 08 72 FD 84 | 	sub	objptr, #8
011cc 46d 9C 5E FC 84 | 	sub	pc, #4*(($+1) - LR__0055)
011d0 46e             | LR__0056
011d0 46e             | '       elseif integer => teni[digits]
011d0 46e 04 72 FD 80 | 	add	objptr, #4
011d4 46f B9 C0 BD 08 | 	rdlong	local06, objptr
011d8 470 02 C0 FD 2C | 	shl	local06, #2
011dc 471 34 97 FD 80 | 	add	ptr__FloatString_dat__, #308
011e0 472 CB C0 BD 80 | 	add	local06, ptr__FloatString_dat__
011e4 473 08 72 FD 80 | 	add	objptr, #8
011e8 474 B9 BC BD 08 | 	rdlong	local04, objptr
011ec 475 0C 72 FD 84 | 	sub	objptr, #12
011f0 476 E0 C2 BD 08 | 	rdlong	local07, local06
011f4 477 E1 BC 3D C1 | 	cmps	local04, local07 wc
011f8 478 34 97 FD 84 | 	sub	ptr__FloatString_dat__, #308
011fc 479 18 5E F0 80 |  if_b	add	pc, #4*(LR__0057 - ($+1))
01200 47a             | '         exponent++
01200 47a 08 72 FD 80 | 	add	objptr, #8
01204 47b B9 BC BD 08 | 	rdlong	local04, objptr
01208 47c 01 BC FD 80 | 	add	local04, #1
0120c 47d B9 BC 3D 08 | 	wrlong	local04, objptr
01210 47e 08 72 FD 84 | 	sub	objptr, #8
01214 47f             | '       else
01214 47f E4 5E FC 84 | 	sub	pc, #4*(($+1) - LR__0055)
01218 480             | LR__0057
01218 480             | '         exponent -= result
01218 480 08 72 FD 80 | 	add	objptr, #8
0121c 481 B9 C0 BD 08 | 	rdlong	local06, objptr
01220 482 DC C0 BD 84 | 	sub	local06, local02
01224 483 B9 C0 3D 08 | 	wrlong	local06, objptr
01228 484 08 72 FD 84 | 	sub	objptr, #8
0122c 485             | '         quit
0122c 485 18 5E FC 80 | 	add	pc, #4*(LR__0059 - ($+1))
01230 486             | ' 
01230 486             | '   'if 0, reset exponent and integer
01230 486             | '   else
01230 486             | LR__0058
01230 486             | '     exponent~
01230 486 00 C0 FD A0 | 	mov	local06, #0
01234 487 08 72 FD 80 | 	add	objptr, #8
01238 488 B9 C0 3D 08 | 	wrlong	local06, objptr
0123c 489             | '     integer~
0123c 489 04 72 FD 80 | 	add	objptr, #4
01240 48a B9 C0 3D 08 | 	wrlong	local06, objptr
01244 48b 0C 72 FD 84 | 	sub	objptr, #12
01248 48c             | LR__0059
01248 48c             | ' 
01248 48c             | '   'set initial tens and clear zeros
01248 48c             | '   tens := teni[digits - 1]
01248 48c 04 72 FD 80 | 	add	objptr, #4
0124c 48d B9 BC BD 08 | 	rdlong	local04, objptr
01250 48e 01 BC FD 84 | 	sub	local04, #1
01254 48f 02 BC FD 2C | 	shl	local04, #2
01258 490 34 97 FD 80 | 	add	ptr__FloatString_dat__, #308
0125c 491 CB BC BD 80 | 	add	local04, ptr__FloatString_dat__
01260 492 DE C2 BD 08 | 	rdlong	local07, local04
01264 493 0C 72 FD 80 | 	add	objptr, #12
01268 494 B9 C2 3D 08 | 	wrlong	local07, objptr
0126c 495             | '   zeros~
0126c 495 00 C0 FD A0 | 	mov	local06, #0
01270 496 04 72 FD 80 | 	add	objptr, #4
01274 497 B9 C0 3D 08 | 	wrlong	local06, objptr
01278 498             | ' 
01278 498             | '   'return pointer to string
01278 498             | '   stringptr := @float_string
01278 498 18 72 FD 80 | 	add	objptr, #24
0127c 499 B9 9E BD A0 | 	mov	result1, objptr
01280 49a 2C 72 FD 84 | 	sub	objptr, #44
01284 49b 34 97 FD 84 | 	sub	ptr__FloatString_dat__, #308
01288 49c 9F A0 BD A0 | 	mov	sp, fp
0128c 49d 6B EE FC 5C | 	call	#popregs_
01290 49e             | _FloatString_Setup_ret
01290 49e 3B 84 FC 5C | 	call	#LMM_RET
01294 49f             | 
01294 49f             | ' 
01294 49f             | ' 
01294 49f             | ' PRI DoScientific
01294 49f             | _FloatString_DoScientific
01294 49f             | ' 
01294 49f             | '   'add digits with possible decimal
01294 49f             | '   AddDigits(1)
01294 49f 01 AC FD A0 | 	mov	arg01, #1
01298 4a0 33 84 FC 5C | 	call	#LMM_CALL
0129c 4a1 9C 13 00 00 | 	long	@@@_FloatString_AddDigits
012a0 4a2             | '   'add exponent indicator
012a0 4a2             | '   byte[p++] := "e"
012a0 4a2 B9 CA BD 08 | 	rdlong	muldivb_, objptr
012a4 4a3 E5 C8 BD A0 | 	mov	muldiva_, muldivb_
012a8 4a4 01 C8 FD 80 | 	add	muldiva_, #1
012ac 4a5 B9 C8 3D 08 | 	wrlong	muldiva_, objptr
012b0 4a6 65 C8 FD A0 | 	mov	muldiva_, #101
012b4 4a7 E5 C8 3D 00 | 	wrbyte	muldiva_, muldivb_
012b8 4a8             | '   'add exponent sign
012b8 4a8             | '   if exponent => 0
012b8 4a8 08 72 FD 80 | 	add	objptr, #8
012bc 4a9 B9 CA BD 08 | 	rdlong	muldivb_, objptr
012c0 4aa 08 72 FD 84 | 	sub	objptr, #8
012c4 4ab 00 CA 7D C1 | 	cmps	muldivb_, #0 wc
012c8 4ac 1C 5E F0 80 |  if_b	add	pc, #4*(LR__0060 - ($+1))
012cc 4ad             | '     byte[p++] := "+"
012cc 4ad B9 CA BD 08 | 	rdlong	muldivb_, objptr
012d0 4ae E5 C8 BD A0 | 	mov	muldiva_, muldivb_
012d4 4af 01 C8 FD 80 | 	add	muldiva_, #1
012d8 4b0 B9 C8 3D 08 | 	wrlong	muldiva_, objptr
012dc 4b1 2B C8 FD A0 | 	mov	muldiva_, #43
012e0 4b2 E5 C8 3D 00 | 	wrbyte	muldiva_, muldivb_
012e4 4b3             | '   else
012e4 4b3 2C 5E FC 80 | 	add	pc, #4*(LR__0061 - ($+1))
012e8 4b4             | LR__0060
012e8 4b4             | '     byte[p++] := "-"
012e8 4b4 B9 CA BD 08 | 	rdlong	muldivb_, objptr
012ec 4b5 E5 C8 BD A0 | 	mov	muldiva_, muldivb_
012f0 4b6 01 C8 FD 80 | 	add	muldiva_, #1
012f4 4b7 B9 C8 3D 08 | 	wrlong	muldiva_, objptr
012f8 4b8 2D C8 FD A0 | 	mov	muldiva_, #45
012fc 4b9 E5 C8 3D 00 | 	wrbyte	muldiva_, muldivb_
01300 4ba             | '     ||exponent
01300 4ba 08 72 FD 80 | 	add	objptr, #8
01304 4bb B9 CA BD 08 | 	rdlong	muldivb_, objptr
01308 4bc E5 CA BD A8 | 	abs	muldivb_, muldivb_
0130c 4bd B9 CA 3D 08 | 	wrlong	muldivb_, objptr
01310 4be 08 72 FD 84 | 	sub	objptr, #8
01314 4bf             | LR__0061
01314 4bf             | '   'add exponent digits
01314 4bf             | '   if exponent => 10
01314 4bf 08 72 FD 80 | 	add	objptr, #8
01318 4c0 B9 CA BD 08 | 	rdlong	muldivb_, objptr
0131c 4c1 08 72 FD 84 | 	sub	objptr, #8
01320 4c2 0A CA 7D C1 | 	cmps	muldivb_, #10 wc
01324 4c3 4C 5E F0 80 |  if_b	add	pc, #4*(LR__0062 - ($+1))
01328 4c4             | '     byte[p++] := exponent / 10 + "0"
01328 4c4 08 72 FD 80 | 	add	objptr, #8
0132c 4c5 B9 C8 BD 08 | 	rdlong	muldiva_, objptr
01330 4c6 08 72 FD 84 | 	sub	objptr, #8
01334 4c7 0A CA FD A0 | 	mov	muldivb_, #10
01338 4c8 8C 3A FD 5C | 	call	#divide_
0133c 4c9 30 CA FD 80 | 	add	muldivb_, #48
01340 4ca B9 C8 BD 08 | 	rdlong	muldiva_, objptr
01344 4cb E4 AC BD A0 | 	mov	arg01, muldiva_
01348 4cc 01 AC FD 80 | 	add	arg01, #1
0134c 4cd B9 AC 3D 08 | 	wrlong	arg01, objptr
01350 4ce E4 CA 3D 00 | 	wrbyte	muldivb_, muldiva_
01354 4cf             | '     exponent //= 10
01354 4cf 08 72 FD 80 | 	add	objptr, #8
01358 4d0 B9 C8 BD 08 | 	rdlong	muldiva_, objptr
0135c 4d1 08 72 FD 84 | 	sub	objptr, #8
01360 4d2 0A CA FD A0 | 	mov	muldivb_, #10
01364 4d3 8C 3A FD 5C | 	call	#divide_
01368 4d4 08 72 FD 80 | 	add	objptr, #8
0136c 4d5 B9 C8 3D 08 | 	wrlong	muldiva_, objptr
01370 4d6 08 72 FD 84 | 	sub	objptr, #8
01374 4d7             | LR__0062
01374 4d7             | '   byte[p++] := exponent + "0"
01374 4d7 08 72 FD 80 | 	add	objptr, #8
01378 4d8 B9 CA BD 08 | 	rdlong	muldivb_, objptr
0137c 4d9 08 72 FD 84 | 	sub	objptr, #8
01380 4da 30 CA FD 80 | 	add	muldivb_, #48
01384 4db B9 C8 BD 08 | 	rdlong	muldiva_, objptr
01388 4dc E4 AC BD A0 | 	mov	arg01, muldiva_
0138c 4dd 01 AC FD 80 | 	add	arg01, #1
01390 4de B9 AC 3D 08 | 	wrlong	arg01, objptr
01394 4df E4 CA 3D 00 | 	wrbyte	muldivb_, muldiva_
01398 4e0             | _FloatString_DoScientific_ret
01398 4e0 3B 84 FC 5C | 	call	#LMM_RET
0139c 4e1             | 
0139c 4e1             | ' 
0139c 4e1             | ' 
0139c 4e1             | ' PRI AddDigits(leading) | i
0139c 4e1             | _FloatString_AddDigits
0139c 4e1 06 B8 FC A0 | 	mov	COUNT_, #6
013a0 4e2 5E D4 FC 5C | 	call	#pushregs_
013a4 4e3 D6 B6 BD A0 | 	mov	local01, arg01
013a8 4e4             | ' 
013a8 4e4             | '   'add leading digits
013a8 4e4             | '   repeat i := leading
013a8 4e4 DB B8 BD A0 | 	mov	local02, local01
013ac 4e5 DB BA BD A2 | 	mov	local03, local01 wz
013b0 4e6 5C 5E E8 80 |  if_e	add	pc, #4*(LR__0066 - ($+1))
013b4 4e7             | LR__0063
013b4 4e7             | '     AddDigit
013b4 4e7 33 84 FC 5C | 	call	#LMM_CALL
013b8 4e8 A0 14 00 00 | 	long	@@@_FloatString_AddDigit
013bc 4e9             | '     'add any thousands separator between thousands
013bc 4e9             | '     if thousands_chr
013bc 4e9 24 72 FD 80 | 	add	objptr, #36
013c0 4ea B9 BC BD 0A | 	rdlong	local04, objptr wz
013c4 4eb 24 72 FD 84 | 	sub	objptr, #36
013c8 4ec 3C 5E E8 80 |  if_e	add	pc, #4*(LR__0065 - ($+1))
013cc 4ed             | '       i--
013cc 4ed 01 B8 FD 86 | 	sub	local02, #1 wz
013d0 4ee             | '       if i and not i // 3
013d0 4ee 34 5E E8 80 |  if_e	add	pc, #4*(LR__0064 - ($+1))
013d4 4ef DC C8 BD A0 | 	mov	muldiva_, local02
013d8 4f0 03 CA FD A0 | 	mov	muldivb_, #3
013dc 4f1 8C 3A FD 5C | 	call	#divide_
013e0 4f2 00 C8 7D 86 | 	cmp	muldiva_, #0 wz
013e4 4f3 20 5E D4 80 |  if_ne	add	pc, #4*(LR__0064 - ($+1))
013e8 4f4             | '         byte[p++] := thousands_chr
013e8 4f4 B9 BC BD 08 | 	rdlong	local04, objptr
013ec 4f5 DE BE BD A0 | 	mov	local05, local04
013f0 4f6 01 BE FD 80 | 	add	local05, #1
013f4 4f7 B9 BE 3D 08 | 	wrlong	local05, objptr
013f8 4f8 24 72 FD 80 | 	add	objptr, #36
013fc 4f9 B9 C0 BD 08 | 	rdlong	local06, objptr
01400 4fa 24 72 FD 84 | 	sub	objptr, #36
01404 4fb DE C0 3D 00 | 	wrbyte	local06, local04
01408 4fc             | LR__0064
01408 4fc             | LR__0065
01408 4fc 39 BA FD E4 | 	djnz	local03, #LMM_JUMP
0140c 4fd B4 13 00 00 | 	long	@@@LR__0063
01410 4fe             | LR__0066
01410 4fe             | '   'if trailing digits, add decimal character
01410 4fe             | '   if digits
01410 4fe 04 72 FD 80 | 	add	objptr, #4
01414 4ff B9 BC BD 0A | 	rdlong	local04, objptr wz
01418 500 04 72 FD 84 | 	sub	objptr, #4
0141c 501 74 5E E8 80 |  if_e	add	pc, #4*(LR__0071 - ($+1))
01420 502             | '     AddDecimal
01420 502 33 84 FC 5C | 	call	#LMM_CALL
01424 503 90 15 00 00 | 	long	@@@_FloatString_AddDecimal
01428 504             | '     'then add trailing digits
01428 504             | '     repeat while digits
01428 504             | LR__0067
01428 504 04 72 FD 80 | 	add	objptr, #4
0142c 505 B9 BC BD 0A | 	rdlong	local04, objptr wz
01430 506 04 72 FD 84 | 	sub	objptr, #4
01434 507 5C 5E E8 80 |  if_e	add	pc, #4*(LR__0070 - ($+1))
01438 508             | '       'add any thousandths separator between thousandths
01438 508             | '       if thousandths_chr
01438 508 28 72 FD 80 | 	add	objptr, #40
0143c 509 B9 BC BD 0A | 	rdlong	local04, objptr wz
01440 50a 28 72 FD 84 | 	sub	objptr, #40
01444 50b 3C 5E E8 80 |  if_e	add	pc, #4*(LR__0069 - ($+1))
01448 50c             | '         if i and not i // 3
01448 50c 00 B8 7D 86 | 	cmp	local02, #0 wz
0144c 50d 34 5E E8 80 |  if_e	add	pc, #4*(LR__0068 - ($+1))
01450 50e DC C8 BD A0 | 	mov	muldiva_, local02
01454 50f 03 CA FD A0 | 	mov	muldivb_, #3
01458 510 8C 3A FD 5C | 	call	#divide_
0145c 511 00 C8 7D 86 | 	cmp	muldiva_, #0 wz
01460 512 20 5E D4 80 |  if_ne	add	pc, #4*(LR__0068 - ($+1))
01464 513             | '           byte[p++] := thousandths_chr
01464 513 B9 BC BD 08 | 	rdlong	local04, objptr
01468 514 DE BE BD A0 | 	mov	local05, local04
0146c 515 01 BE FD 80 | 	add	local05, #1
01470 516 B9 BE 3D 08 | 	wrlong	local05, objptr
01474 517 28 72 FD 80 | 	add	objptr, #40
01478 518 B9 C0 BD 08 | 	rdlong	local06, objptr
0147c 519 28 72 FD 84 | 	sub	objptr, #40
01480 51a DE C0 3D 00 | 	wrbyte	local06, local04
01484 51b             | LR__0068
01484 51b             | LR__0069
01484 51b             | '       i++
01484 51b 01 B8 FD 80 | 	add	local02, #1
01488 51c             | '       AddDigit
01488 51c 33 84 FC 5C | 	call	#LMM_CALL
0148c 51d A0 14 00 00 | 	long	@@@_FloatString_AddDigit
01490 51e 6C 5E FC 84 | 	sub	pc, #4*(($+1) - LR__0067)
01494 51f             | LR__0070
01494 51f             | LR__0071
01494 51f 9F A0 BD A0 | 	mov	sp, fp
01498 520 6B EE FC 5C | 	call	#popregs_
0149c 521             | _FloatString_AddDigits_ret
0149c 521 3B 84 FC 5C | 	call	#LMM_RET
014a0 522             | 
014a0 522             | ' 
014a0 522             | ' 
014a0 522             | ' PRI AddDigit
014a0 522             | _FloatString_AddDigit
014a0 522             | ' 
014a0 522             | '   'if leading zeros, add "0"
014a0 522             | '   if zeros
014a0 522 14 72 FD 80 | 	add	objptr, #20
014a4 523 B9 CA BD 0A | 	rdlong	muldivb_, objptr wz
014a8 524 14 72 FD 84 | 	sub	objptr, #20
014ac 525 30 5E E8 80 |  if_e	add	pc, #4*(LR__0072 - ($+1))
014b0 526             | '     byte[p++] := "0"
014b0 526 B9 CA BD 08 | 	rdlong	muldivb_, objptr
014b4 527 E5 C8 BD A0 | 	mov	muldiva_, muldivb_
014b8 528 01 C8 FD 80 | 	add	muldiva_, #1
014bc 529 B9 C8 3D 08 | 	wrlong	muldiva_, objptr
014c0 52a 30 C8 FD A0 | 	mov	muldiva_, #48
014c4 52b E5 C8 3D 00 | 	wrbyte	muldiva_, muldivb_
014c8 52c             | '     zeros--
014c8 52c 14 72 FD 80 | 	add	objptr, #20
014cc 52d B9 CA BD 08 | 	rdlong	muldivb_, objptr
014d0 52e 01 CA FD 84 | 	sub	muldivb_, #1
014d4 52f B9 CA 3D 08 | 	wrlong	muldivb_, objptr
014d8 530 14 72 FD 84 | 	sub	objptr, #20
014dc 531 AC 5E FC 80 | 	add	pc, #4*(LR__0075 - ($+1))
014e0 532             | LR__0072
014e0 532             | '   'if more digits, add current digit and prepare next
014e0 532             | '   elseif digits
014e0 532 04 72 FD 80 | 	add	objptr, #4
014e4 533 B9 CA BD 0A | 	rdlong	muldivb_, objptr wz
014e8 534 04 72 FD 84 | 	sub	objptr, #4
014ec 535 84 5E E8 80 |  if_e	add	pc, #4*(LR__0073 - ($+1))
014f0 536             | '     byte[p++] := integer / tens + "0"
014f0 536 0C 72 FD 80 | 	add	objptr, #12
014f4 537 B9 C8 BD 08 | 	rdlong	muldiva_, objptr
014f8 538 04 72 FD 80 | 	add	objptr, #4
014fc 539 B9 CA BD 08 | 	rdlong	muldivb_, objptr
01500 53a 10 72 FD 84 | 	sub	objptr, #16
01504 53b 8C 3A FD 5C | 	call	#divide_
01508 53c 30 CA FD 80 | 	add	muldivb_, #48
0150c 53d B9 C8 BD 08 | 	rdlong	muldiva_, objptr
01510 53e E4 A2 BD A0 | 	mov	_var01, muldiva_
01514 53f 01 A2 FD 80 | 	add	_var01, #1
01518 540 B9 A2 3D 08 | 	wrlong	_var01, objptr
0151c 541 E4 CA 3D 00 | 	wrbyte	muldivb_, muldiva_
01520 542             | '     integer //= tens
01520 542 0C 72 FD 80 | 	add	objptr, #12
01524 543 B9 C8 BD 08 | 	rdlong	muldiva_, objptr
01528 544 04 72 FD 80 | 	add	objptr, #4
0152c 545 B9 CA BD 08 | 	rdlong	muldivb_, objptr
01530 546 10 72 FD 84 | 	sub	objptr, #16
01534 547 8C 3A FD 5C | 	call	#divide_
01538 548 0C 72 FD 80 | 	add	objptr, #12
0153c 549 B9 C8 3D 08 | 	wrlong	muldiva_, objptr
01540 54a             | '     tens /= 10
01540 54a 04 72 FD 80 | 	add	objptr, #4
01544 54b B9 C8 BD 08 | 	rdlong	muldiva_, objptr
01548 54c 10 72 FD 84 | 	sub	objptr, #16
0154c 54d 0A CA FD A0 | 	mov	muldivb_, #10
01550 54e 8C 3A FD 5C | 	call	#divide_
01554 54f 10 72 FD 80 | 	add	objptr, #16
01558 550 B9 CA 3D 08 | 	wrlong	muldivb_, objptr
0155c 551             | '     digits--
0155c 551 0C 72 FD 84 | 	sub	objptr, #12
01560 552 B9 A2 BD 08 | 	rdlong	_var01, objptr
01564 553 01 A2 FD 84 | 	sub	_var01, #1
01568 554 B9 A2 3D 08 | 	wrlong	_var01, objptr
0156c 555 04 72 FD 84 | 	sub	objptr, #4
01570 556             | '   'if no more digits, add "0"
01570 556             | '   else
01570 556 18 5E FC 80 | 	add	pc, #4*(LR__0074 - ($+1))
01574 557             | LR__0073
01574 557             | '     byte[p++] := "0"
01574 557 B9 A2 BD 08 | 	rdlong	_var01, objptr
01578 558 D1 CA BD A0 | 	mov	muldivb_, _var01
0157c 559 01 CA FD 80 | 	add	muldivb_, #1
01580 55a B9 CA 3D 08 | 	wrlong	muldivb_, objptr
01584 55b 30 CA FD A0 | 	mov	muldivb_, #48
01588 55c D1 CA 3D 00 | 	wrbyte	muldivb_, _var01
0158c 55d             | LR__0074
0158c 55d             | LR__0075
0158c 55d             | _FloatString_AddDigit_ret
0158c 55d 3B 84 FC 5C | 	call	#LMM_RET
01590 55e             | 
01590 55e             | ' 
01590 55e             | ' 
01590 55e             | ' PRI AddDecimal
01590 55e             | _FloatString_AddDecimal
01590 55e             | ' 
01590 55e             | '   if decimal_chr
01590 55e 20 72 FD 80 | 	add	objptr, #32
01594 55f B9 A2 BD 0A | 	rdlong	_var01, objptr wz
01598 560 20 72 FD 84 | 	sub	objptr, #32
0159c 561 24 5E E8 80 |  if_e	add	pc, #4*(LR__0076 - ($+1))
015a0 562             | '     byte[p++] := decimal_chr
015a0 562 B9 A2 BD 08 | 	rdlong	_var01, objptr
015a4 563 D1 A4 BD A0 | 	mov	_var02, _var01
015a8 564 01 A4 FD 80 | 	add	_var02, #1
015ac 565 B9 A4 3D 08 | 	wrlong	_var02, objptr
015b0 566 20 72 FD 80 | 	add	objptr, #32
015b4 567 B9 A4 BD 08 | 	rdlong	_var02, objptr
015b8 568 20 72 FD 84 | 	sub	objptr, #32
015bc 569 D1 A4 3D 00 | 	wrbyte	_var02, _var01
015c0 56a             | '   else
015c0 56a 18 5E FC 80 | 	add	pc, #4*(LR__0077 - ($+1))
015c4 56b             | LR__0076
015c4 56b             | '     byte[p++] := "."
015c4 56b B9 A2 BD 08 | 	rdlong	_var01, objptr
015c8 56c D1 A4 BD A0 | 	mov	_var02, _var01
015cc 56d 01 A4 FD 80 | 	add	_var02, #1
015d0 56e B9 A4 3D 08 | 	wrlong	_var02, objptr
015d4 56f 2E A4 FD A0 | 	mov	_var02, #46
015d8 570 D1 A4 3D 00 | 	wrbyte	_var02, _var01
015dc 571             | LR__0077
015dc 571             | _FloatString_AddDecimal_ret
015dc 571 3B 84 FC 5C | 	call	#LMM_RET
015e0 572             | 
015e0 572             | ' 
015e0 572             | '              
015e0 572             | ' PUB FMul(singleA, singleB) : single | sa, xa, ma, sb, xb, mb
015e0 572             | _FloatMath_FMul
015e0 572 00 B8 FC A0 | 	mov	COUNT_, #0
015e4 573 5E D4 FC 5C | 	call	#pushregs_
015e8 574 24 A0 FD 80 | 	add	sp, #36
015ec 575 04 3E FD 80 | 	add	fp, #4
015f0 576 9F AC 3D 08 | 	wrlong	arg01, fp
015f4 577 04 3E FD 80 | 	add	fp, #4
015f8 578 9F AE 3D 08 | 	wrlong	arg02, fp
015fc 579             | ' 
015fc 579             | ' ''Multiply singleA by singleB
015fc 579             | ' 
015fc 579             | '   Unpack(@sa, singleA)          'unpack inputs
015fc 579 04 3E FD 80 | 	add	fp, #4
01600 57a 9F AC BD A0 | 	mov	arg01, fp
01604 57b 08 3E FD 84 | 	sub	fp, #8
01608 57c 9F AE BD 08 | 	rdlong	arg02, fp
0160c 57d 04 3E FD 84 | 	sub	fp, #4
01610 57e 33 84 FC 5C | 	call	#LMM_CALL
01614 57f A0 17 00 00 | 	long	@@@_FloatMath_Unpack
01618 580             | '   Unpack(@sb, singleB)
01618 580 18 3E FD 80 | 	add	fp, #24
0161c 581 9F AC BD A0 | 	mov	arg01, fp
01620 582 10 3E FD 84 | 	sub	fp, #16
01624 583 9F AE BD 08 | 	rdlong	arg02, fp
01628 584 08 3E FD 84 | 	sub	fp, #8
0162c 585 33 84 FC 5C | 	call	#LMM_CALL
01630 586 A0 17 00 00 | 	long	@@@_FloatMath_Unpack
01634 587             | ' 
01634 587             | '   sa ^= sb                      'xor signs
01634 587 0C 3E FD 80 | 	add	fp, #12
01638 588 9F CA BD 08 | 	rdlong	muldivb_, fp
0163c 589 0C 3E FD 80 | 	add	fp, #12
01640 58a 9F C8 BD 08 | 	rdlong	muldiva_, fp
01644 58b E4 CA BD 6C | 	xor	muldivb_, muldiva_
01648 58c 0C 3E FD 84 | 	sub	fp, #12
0164c 58d 9F CA 3D 08 | 	wrlong	muldivb_, fp
01650 58e             | '   xa += xb                      'add exponents
01650 58e 04 3E FD 80 | 	add	fp, #4
01654 58f 9F CA BD 08 | 	rdlong	muldivb_, fp
01658 590 0C 3E FD 80 | 	add	fp, #12
0165c 591 9F C8 BD 08 | 	rdlong	muldiva_, fp
01660 592 E4 CA BD 80 | 	add	muldivb_, muldiva_
01664 593 0C 3E FD 84 | 	sub	fp, #12
01668 594 9F CA 3D 08 | 	wrlong	muldivb_, fp
0166c 595             | '   ma := (ma ** mb) << 3         'multiply mantissas and justify
0166c 595 04 3E FD 80 | 	add	fp, #4
01670 596 9F C8 BD 08 | 	rdlong	muldiva_, fp
01674 597 0C 3E FD 80 | 	add	fp, #12
01678 598 9F CA BD 08 | 	rdlong	muldivb_, fp
0167c 599 20 3E FD 84 | 	sub	fp, #32
01680 59a 78 12 FD 5C | 	call	#multiply_
01684 59b E5 AC BD A0 | 	mov	arg01, muldivb_
01688 59c 03 AC FD 2C | 	shl	arg01, #3
0168c 59d 14 3E FD 80 | 	add	fp, #20
01690 59e 9F AC 3D 08 | 	wrlong	arg01, fp
01694 59f             | ' 
01694 59f             | '   return Pack(@sa)              'pack result
01694 59f 08 3E FD 84 | 	sub	fp, #8
01698 5a0 9F AC BD A0 | 	mov	arg01, fp
0169c 5a1 0C 3E FD 84 | 	sub	fp, #12
016a0 5a2 33 84 FC 5C | 	call	#LMM_CALL
016a4 5a3 CC 18 00 00 | 	long	@@@_FloatMath_Pack
016a8 5a4 9F A0 BD A0 | 	mov	sp, fp
016ac 5a5 6B EE FC 5C | 	call	#popregs_
016b0 5a6             | _FloatMath_FMul_ret
016b0 5a6 3B 84 FC 5C | 	call	#LMM_RET
016b4 5a7             | 
016b4 5a7             | ' 
016b4 5a7             | ' 
016b4 5a7             | ' PRI FInteger(a, r) : integer | s, x, m
016b4 5a7             | _FloatMath_FInteger
016b4 5a7 00 B8 FC A0 | 	mov	COUNT_, #0
016b8 5a8 5E D4 FC 5C | 	call	#pushregs_
016bc 5a9 18 A0 FD 80 | 	add	sp, #24
016c0 5aa 04 3E FD 80 | 	add	fp, #4
016c4 5ab 9F AC 3D 08 | 	wrlong	arg01, fp
016c8 5ac 04 3E FD 80 | 	add	fp, #4
016cc 5ad 9F AE 3D 08 | 	wrlong	arg02, fp
016d0 5ae             | ' 
016d0 5ae             | ' 'Convert float to rounded/truncated integer
016d0 5ae             | ' 
016d0 5ae             | '   Unpack(@s, a)                 'unpack input
016d0 5ae 04 3E FD 80 | 	add	fp, #4
016d4 5af 9F AC BD A0 | 	mov	arg01, fp
016d8 5b0 08 3E FD 84 | 	sub	fp, #8
016dc 5b1 9F AE BD 08 | 	rdlong	arg02, fp
016e0 5b2 04 3E FD 84 | 	sub	fp, #4
016e4 5b3 33 84 FC 5C | 	call	#LMM_CALL
016e8 5b4 A0 17 00 00 | 	long	@@@_FloatMath_Unpack
016ec 5b5             | ' 
016ec 5b5             | '   if x => -1 and x =< 30        'if exponent not -1..30, result 0
016ec 5b5 10 3E FD 80 | 	add	fp, #16
016f0 5b6 9F 9E BD 08 | 	rdlong	result1, fp
016f4 5b7 10 3E FD 84 | 	sub	fp, #16
016f8 5b8 AF 9E 3D C1 | 	cmps	result1, imm_4294967295_ wc
016fc 5b9 90 5E F0 80 |  if_b	add	pc, #4*(LR__0079 - ($+1))
01700 5ba 10 3E FD 80 | 	add	fp, #16
01704 5bb 9F 9E BD 08 | 	rdlong	result1, fp
01708 5bc 10 3E FD 84 | 	sub	fp, #16
0170c 5bd 1F 9E 7D C1 | 	cmps	result1, #31 wc
01710 5be 7C 5E CC 80 |  if_ae	add	pc, #4*(LR__0079 - ($+1))
01714 5bf             | '     m <<= 2                     'msb-justify mantissa
01714 5bf 14 3E FD 80 | 	add	fp, #20
01718 5c0 9F 9E BD 08 | 	rdlong	result1, fp
0171c 5c1 02 9E FD 2C | 	shl	result1, #2
01720 5c2 9F 9E 3D 08 | 	wrlong	result1, fp
01724 5c3             | '     m >>= 30 - x                'shift down to 1/2-lsb
01724 5c3 1E AE FD A0 | 	mov	arg02, #30
01728 5c4 04 3E FD 84 | 	sub	fp, #4
0172c 5c5 9F AC BD 08 | 	rdlong	arg01, fp
01730 5c6 D6 AE BD 84 | 	sub	arg02, arg01
01734 5c7 D7 9E BD 28 | 	shr	result1, arg02
01738 5c8 04 3E FD 80 | 	add	fp, #4
0173c 5c9 9F 9E 3D 08 | 	wrlong	result1, fp
01740 5ca             | '     m += r                      'round (1) or truncate (0)
01740 5ca 0C 3E FD 84 | 	sub	fp, #12
01744 5cb 9F AE BD 08 | 	rdlong	arg02, fp
01748 5cc D7 9E BD 80 | 	add	result1, arg02
0174c 5cd 0C 3E FD 80 | 	add	fp, #12
01750 5ce 9F 9E 3D 08 | 	wrlong	result1, fp
01754 5cf             | '     m >>= 1                     'shift down to lsb
01754 5cf 01 9E FD 28 | 	shr	result1, #1
01758 5d0 9F 9E 3D 08 | 	wrlong	result1, fp
0175c 5d1             | '     if s                        'handle negation
0175c 5d1 08 3E FD 84 | 	sub	fp, #8
01760 5d2 9F 9E BD 0A | 	rdlong	result1, fp wz
01764 5d3 0C 3E FD 84 | 	sub	fp, #12
01768 5d4 14 5E E8 80 |  if_e	add	pc, #4*(LR__0078 - ($+1))
0176c 5d5             | '       -m
0176c 5d5 14 3E FD 80 | 	add	fp, #20
01770 5d6 9F 9E BD 08 | 	rdlong	result1, fp
01774 5d7 CF 9E BD A4 | 	neg	result1, result1
01778 5d8 9F 9E 3D 08 | 	wrlong	result1, fp
0177c 5d9 14 3E FD 84 | 	sub	fp, #20
01780 5da             | LR__0078
01780 5da             | '     return m                    'return integer
01780 5da 14 3E FD 80 | 	add	fp, #20
01784 5db 9F 9E BD 08 | 	rdlong	result1, fp
01788 5dc 14 3E FD 84 | 	sub	fp, #20
0178c 5dd 04 5E FC 80 | 	add	pc, #4*(LR__0080 - ($+1))
01790 5de             | LR__0079
01790 5de 00 9E FD A0 | 	mov	result1, #0
01794 5df             | LR__0080
01794 5df 9F A0 BD A0 | 	mov	sp, fp
01798 5e0 6B EE FC 5C | 	call	#popregs_
0179c 5e1             | _FloatMath_FInteger_ret
0179c 5e1 3B 84 FC 5C | 	call	#LMM_RET
017a0 5e2             | 
017a0 5e2             | ' 
017a0 5e2             | '       
017a0 5e2             | ' PRI Unpack(pointer, single) | s, x, m
017a0 5e2             | _FloatMath_Unpack
017a0 5e2 02 B8 FC A0 | 	mov	COUNT_, #2
017a4 5e3 5E D4 FC 5C | 	call	#pushregs_
017a8 5e4 18 A0 FD 80 | 	add	sp, #24
017ac 5e5 04 3E FD 80 | 	add	fp, #4
017b0 5e6 9F AC 3D 08 | 	wrlong	arg01, fp
017b4 5e7 04 3E FD 80 | 	add	fp, #4
017b8 5e8 9F AE 3D 08 | 	wrlong	arg02, fp
017bc 5e9 08 3E FD 84 | 	sub	fp, #8
017c0 5ea 00 9E FD A0 | 	mov	result1, #0
017c4 5eb 9F 9E 3D 08 | 	wrlong	result1, fp
017c8 5ec             | ' 
017c8 5ec             | ' 'Unpack floating-point into (sign, exponent, mantissa) at pointer
017c8 5ec             | ' 
017c8 5ec             | '   s := single >> 31             'unpack sign
017c8 5ec 08 3E FD 80 | 	add	fp, #8
017cc 5ed 9F 9E BD 08 | 	rdlong	result1, fp
017d0 5ee 1F 9E FD 28 | 	shr	result1, #31
017d4 5ef 04 3E FD 80 | 	add	fp, #4
017d8 5f0 9F 9E 3D 08 | 	wrlong	result1, fp
017dc 5f1             | '   x := single << 1 >> 24        'unpack exponent
017dc 5f1 04 3E FD 84 | 	sub	fp, #4
017e0 5f2 9F 9E BD 08 | 	rdlong	result1, fp
017e4 5f3 01 9E FD 2C | 	shl	result1, #1
017e8 5f4 18 9E FD 28 | 	shr	result1, #24
017ec 5f5 08 3E FD 80 | 	add	fp, #8
017f0 5f6 9F 9E 3D 08 | 	wrlong	result1, fp
017f4 5f7             | '   m := single & $007F_FFFF      'unpack mantissa
017f4 5f7 08 3E FD 84 | 	sub	fp, #8
017f8 5f8 9F 9E BD 08 | 	rdlong	result1, fp
017fc 5f9 B5 9E BD 60 | 	and	result1, imm_8388607_
01800 5fa 0C 3E FD 80 | 	add	fp, #12
01804 5fb 9F 9E 3D 08 | 	wrlong	result1, fp
01808 5fc             | ' 
01808 5fc             | '   if x                          'if exponent > 0,
01808 5fc 04 3E FD 84 | 	sub	fp, #4
0180c 5fd 9F 9E BD 0A | 	rdlong	result1, fp wz
01810 5fe 10 3E FD 84 | 	sub	fp, #16
01814 5ff 1C 5E E8 80 |  if_e	add	pc, #4*(LR__0081 - ($+1))
01818 600             | '     m := m << 6 | $2000_0000    '..bit29-justify mantissa with leading 1
01818 600 14 3E FD 80 | 	add	fp, #20
0181c 601 9F 9E BD 08 | 	rdlong	result1, fp
01820 602 06 9E FD 2C | 	shl	result1, #6
01824 603 B0 9E BD 68 | 	or	result1, imm_536870912_
01828 604 9F 9E 3D 08 | 	wrlong	result1, fp
0182c 605 14 3E FD 84 | 	sub	fp, #20
01830 606             | '   else
01830 606 58 5E FC 80 | 	add	pc, #4*(LR__0084 - ($+1))
01834 607             | LR__0081
01834 607             | '     result := >|m - 23          'else, determine first 1 in mantissa
01834 607 14 3E FD 80 | 	add	fp, #20
01838 608 9F B6 BD 08 | 	rdlong	local01, fp
0183c 609 14 3E FD 84 | 	sub	fp, #20
01840 60a 20 B8 FD A0 | 	mov	local02, #32
01844 60b 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01848 60c 08 00 00 00 | 	long	(@@@LR__0083-@@@LR__0082)
0184c 60d             | LR__0082
0184c 60d 01 B6 FD 2D | 	shl	local01, #1 wc
01850 60e E7 B8 CD E4 |  if_ae	djnz	local02, #LMM_FCACHE_START + (LR__0082 - LR__0082)
01854 60f             | LR__0083
01854 60f 17 B8 FD 84 | 	sub	local02, #23
01858 610 9F B8 3D 08 | 	wrlong	local02, fp
0185c 611             | '     x := result                 '..adjust exponent
0185c 611 10 3E FD 80 | 	add	fp, #16
01860 612 9F B8 3D 08 | 	wrlong	local02, fp
01864 613             | '     m <<= 7 - result            '..bit29-justify mantissa
01864 613 04 3E FD 80 | 	add	fp, #4
01868 614 9F B8 BD 08 | 	rdlong	local02, fp
0186c 615 14 3E FD 84 | 	sub	fp, #20
01870 616 07 B6 FD A0 | 	mov	local01, #7
01874 617 9F 9E BD 08 | 	rdlong	result1, fp
01878 618 CF B6 BD 84 | 	sub	local01, result1
0187c 619 DB B8 BD 2C | 	shl	local02, local01
01880 61a 14 3E FD 80 | 	add	fp, #20
01884 61b 9F B8 3D 08 | 	wrlong	local02, fp
01888 61c 14 3E FD 84 | 	sub	fp, #20
0188c 61d             | LR__0084
0188c 61d             | ' 
0188c 61d             | '   x -= 127                      'unbias exponent
0188c 61d 10 3E FD 80 | 	add	fp, #16
01890 61e 9F B8 BD 08 | 	rdlong	local02, fp
01894 61f 7F B8 FD 84 | 	sub	local02, #127
01898 620 9F B8 3D 08 | 	wrlong	local02, fp
0189c 621             | ' 
0189c 621             | '   longmove(pointer, @s, 3)      'write (s,x,m) structure from locals
0189c 621 0C 3E FD 84 | 	sub	fp, #12
018a0 622 9F AC BD 08 | 	rdlong	arg01, fp
018a4 623 08 3E FD 80 | 	add	fp, #8
018a8 624 9F AE BD A0 | 	mov	arg02, fp
018ac 625 0C 3E FD 84 | 	sub	fp, #12
018b0 626 03 B0 FD A0 | 	mov	arg03, #3
018b4 627 33 84 FC 5C | 	call	#LMM_CALL
018b8 628 B0 1D 00 00 | 	long	@@@__system__longmove
018bc 629 9F 9E BD 08 | 	rdlong	result1, fp
018c0 62a 9F A0 BD A0 | 	mov	sp, fp
018c4 62b 6B EE FC 5C | 	call	#popregs_
018c8 62c             | _FloatMath_Unpack_ret
018c8 62c 3B 84 FC 5C | 	call	#LMM_RET
018cc 62d             | 
018cc 62d             | '   
018cc 62d             | '   
018cc 62d             | ' PRI Pack(pointer) : single | s, x, m
018cc 62d             | _FloatMath_Pack
018cc 62d 02 B8 FC A0 | 	mov	COUNT_, #2
018d0 62e 5E D4 FC 5C | 	call	#pushregs_
018d4 62f 14 A0 FD 80 | 	add	sp, #20
018d8 630 04 3E FD 80 | 	add	fp, #4
018dc 631 9F AC 3D 08 | 	wrlong	arg01, fp
018e0 632 04 3E FD 84 | 	sub	fp, #4
018e4 633 00 9E FD A0 | 	mov	result1, #0
018e8 634 9F 9E 3D 08 | 	wrlong	result1, fp
018ec 635             | ' 
018ec 635             | ' 'Pack floating-point from (sign, exponent, mantissa) at pointer
018ec 635             | ' 
018ec 635             | '   longmove(@s, pointer, 3)      'get (s,x,m) structure into locals
018ec 635 08 3E FD 80 | 	add	fp, #8
018f0 636 9F AC BD A0 | 	mov	arg01, fp
018f4 637 04 3E FD 84 | 	sub	fp, #4
018f8 638 9F AE BD 08 | 	rdlong	arg02, fp
018fc 639 04 3E FD 84 | 	sub	fp, #4
01900 63a 03 B0 FD A0 | 	mov	arg03, #3
01904 63b 33 84 FC 5C | 	call	#LMM_CALL
01908 63c B0 1D 00 00 | 	long	@@@__system__longmove
0190c 63d             | ' 
0190c 63d             | '   if m                          'if mantissa 0, result 0
0190c 63d 10 3E FD 80 | 	add	fp, #16
01910 63e 9F 9E BD 0A | 	rdlong	result1, fp wz
01914 63f 10 3E FD 84 | 	sub	fp, #16
01918 640 28 5F E8 80 |  if_e	add	pc, #4*(LR__0089 - ($+1))
0191c 641             | '   
0191c 641             | '     result := 33 - >|m          'determine magnitude of mantissa
0191c 641 10 3E FD 80 | 	add	fp, #16
01920 642 9F B6 BD 08 | 	rdlong	local01, fp
01924 643 10 3E FD 84 | 	sub	fp, #16
01928 644 20 B8 FD A0 | 	mov	local02, #32
0192c 645 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01930 646 08 00 00 00 | 	long	(@@@LR__0086-@@@LR__0085)
01934 647             | LR__0085
01934 647 01 B6 FD 2D | 	shl	local01, #1 wc
01938 648 E7 B8 CD E4 |  if_ae	djnz	local02, #LMM_FCACHE_START + (LR__0085 - LR__0085)
0193c 649             | LR__0086
0193c 649 21 B6 FD A0 | 	mov	local01, #33
01940 64a DC B6 BD 84 | 	sub	local01, local02
01944 64b 9F B6 3D 08 | 	wrlong	local01, fp
01948 64c             | '     m <<= result                'msb-justify mantissa without leading 1
01948 64c 10 3E FD 80 | 	add	fp, #16
0194c 64d 9F B8 BD 08 | 	rdlong	local02, fp
01950 64e DB B8 BD 2C | 	shl	local02, local01
01954 64f 9F B8 3D 08 | 	wrlong	local02, fp
01958 650             | '     x += 3 - result             'adjust exponent
01958 650 04 3E FD 84 | 	sub	fp, #4
0195c 651 9F B8 BD 08 | 	rdlong	local02, fp
01960 652 0C 3E FD 84 | 	sub	fp, #12
01964 653 03 9E FD A0 | 	mov	result1, #3
01968 654 9F B6 BD 08 | 	rdlong	local01, fp
0196c 655 DB 9E BD 84 | 	sub	result1, local01
01970 656 CF B8 BD 80 | 	add	local02, result1
01974 657 0C 3E FD 80 | 	add	fp, #12
01978 658 9F B8 3D 08 | 	wrlong	local02, fp
0197c 659             | ' 
0197c 659             | '     m += $00000100              'round up mantissa by 1/2 lsb
0197c 659 04 3E FD 80 | 	add	fp, #4
01980 65a 9F B8 BD 08 | 	rdlong	local02, fp
01984 65b 00 B9 FD 80 | 	add	local02, #256
01988 65c 9F B8 3D 08 | 	wrlong	local02, fp
0198c 65d             | '     if not m & $FFFFFF00        'if rounding overflow,
0198c 65d 10 3E FD 84 | 	sub	fp, #16
01990 65e FF B8 FD 66 | 	andn	local02, #255 wz
01994 65f 14 5E D4 80 |  if_ne	add	pc, #4*(LR__0087 - ($+1))
01998 660             | '       x++                       '..increment exponent
01998 660 0C 3E FD 80 | 	add	fp, #12
0199c 661 9F B8 BD 08 | 	rdlong	local02, fp
019a0 662 01 B8 FD 80 | 	add	local02, #1
019a4 663 9F B8 3D 08 | 	wrlong	local02, fp
019a8 664 0C 3E FD 84 | 	sub	fp, #12
019ac 665             | LR__0087
019ac 665             | '     
019ac 665             | '     x := x + 127 #> -23 <# 255  'bias and limit exponent
019ac 665 0C 3E FD 80 | 	add	fp, #12
019b0 666 9F B8 BD 08 | 	rdlong	local02, fp
019b4 667 7F B8 FD 80 | 	add	local02, #127
019b8 668 AE B8 BD 40 | 	mins	local02, imm_4294967273_
019bc 669 FF B8 FD 44 | 	maxs	local02, #255
019c0 66a 9F B8 3D 08 | 	wrlong	local02, fp
019c4 66b             | ' 
019c4 66b             | '     if x < 1                    'if exponent < 1,
019c4 66b 0C 3E FD 84 | 	sub	fp, #12
019c8 66c 01 B8 7D C1 | 	cmps	local02, #1 wc
019cc 66d 40 5E CC 80 |  if_ae	add	pc, #4*(LR__0088 - ($+1))
019d0 66e             | '       m := $8000_0000 +  m >> 1 '..replace leading 1
019d0 66e 10 3E FD 80 | 	add	fp, #16
019d4 66f 9F B8 BD 08 | 	rdlong	local02, fp
019d8 670 01 B8 FD 28 | 	shr	local02, #1
019dc 671 A9 B6 BD A0 | 	mov	local01, imm_2147483648_
019e0 672 DC B6 BD 80 | 	add	local01, local02
019e4 673 9F B6 3D 08 | 	wrlong	local01, fp
019e8 674             | '       m >>= -x                  '..shift mantissa down by exponent
019e8 674 04 3E FD 84 | 	sub	fp, #4
019ec 675 9F B8 BD 08 | 	rdlong	local02, fp
019f0 676 DC B8 BD A4 | 	neg	local02, local02
019f4 677 DC B6 BD 28 | 	shr	local01, local02
019f8 678 04 3E FD 80 | 	add	fp, #4
019fc 679 9F B6 3D 08 | 	wrlong	local01, fp
01a00 67a             | '       x~                        '..exponent is now 0
01a00 67a 00 B8 FD A0 | 	mov	local02, #0
01a04 67b 04 3E FD 84 | 	sub	fp, #4
01a08 67c 9F B8 3D 08 | 	wrlong	local02, fp
01a0c 67d 0C 3E FD 84 | 	sub	fp, #12
01a10 67e             | LR__0088
01a10 67e             | ' 
01a10 67e             | '     return s << 31 | x << 23 | m >> 9 'pack result
01a10 67e 08 3E FD 80 | 	add	fp, #8
01a14 67f 9F 9E BD 08 | 	rdlong	result1, fp
01a18 680 1F 9E FD 2C | 	shl	result1, #31
01a1c 681 04 3E FD 80 | 	add	fp, #4
01a20 682 9F B8 BD 08 | 	rdlong	local02, fp
01a24 683 17 B8 FD 2C | 	shl	local02, #23
01a28 684 DC 9E BD 68 | 	or	result1, local02
01a2c 685 04 3E FD 80 | 	add	fp, #4
01a30 686 9F B8 BD 08 | 	rdlong	local02, fp
01a34 687 10 3E FD 84 | 	sub	fp, #16
01a38 688 09 B8 FD 28 | 	shr	local02, #9
01a3c 689 DC 9E BD 68 | 	or	result1, local02
01a40 68a 04 5E FC 80 | 	add	pc, #4*(LR__0090 - ($+1))
01a44 68b             | LR__0089
01a44 68b 9F 9E BD 08 | 	rdlong	result1, fp
01a48 68c             | LR__0090
01a48 68c 9F A0 BD A0 | 	mov	sp, fp
01a4c 68d 6B EE FC 5C | 	call	#popregs_
01a50 68e             | _FloatMath_Pack_ret
01a50 68e 3B 84 FC 5C | 	call	#LMM_RET
01a54 68f             | 
01a54 68f             | '   
01a54 68f             | ' PUB start : okay
01a54 68f             | _Float32_start
01a54 68f             | ' {{Start start floating point engine in a new cog.
01a54 68f             | '   Returns:     True (non-zero) if cog started, or False (0) if no cog is available.}}
01a54 68f             | ' 
01a54 68f             | '   stop
01a54 68f 33 84 FC 5C | 	call	#LMM_CALL
01a58 690 84 1A 00 00 | 	long	@@@_Float32_stop
01a5c 691             | '   okay := cog := cognew(@getCommand, @command) + 1
01a5c 691 CA AE BD A0 | 	mov	arg02, ptr__Float32_dat__
01a60 692 04 72 FD 80 | 	add	objptr, #4
01a64 693 B9 B0 BD A0 | 	mov	arg03, objptr
01a68 694 04 72 FD 84 | 	sub	objptr, #4
01a6c 695 1E AC FD A0 | 	mov	arg01, #30
01a70 696 33 84 FC 5C | 	call	#LMM_CALL
01a74 697 1C 1D 00 00 | 	long	@@@__system___coginit
01a78 698 01 9E FD 80 | 	add	result1, #1
01a7c 699 B9 9E 3D 08 | 	wrlong	result1, objptr
01a80 69a             | _Float32_start_ret
01a80 69a 3B 84 FC 5C | 	call	#LMM_RET
01a84 69b             | 
01a84 69b             | ' 
01a84 69b             | ' PUB stop
01a84 69b             | _Float32_stop
01a84 69b 01 B8 FC A0 | 	mov	COUNT_, #1
01a88 69c 5E D4 FC 5C | 	call	#pushregs_
01a8c 69d             | ' {{Stop floating point engine and release the cog.}}
01a8c 69d             | ' 
01a8c 69d             | '   if cog
01a8c 69d B9 AC BD 0A | 	rdlong	arg01, objptr wz
01a90 69e 14 5E E8 80 |  if_e	add	pc, #4*(LR__0091 - ($+1))
01a94 69f             | '     cogstop(cog~ - 1)
01a94 69f B9 AC BD 08 | 	rdlong	arg01, objptr
01a98 6a0 00 B6 FD A0 | 	mov	local01, #0
01a9c 6a1 B9 B6 3D 08 | 	wrlong	local01, objptr
01aa0 6a2 01 AC FD 84 | 	sub	arg01, #1
01aa4 6a3 03 AC 7D 0C | 	cogstop	arg01
01aa8 6a4             | LR__0091
01aa8 6a4             | '   command~
01aa8 6a4 00 B6 FD A0 | 	mov	local01, #0
01aac 6a5 04 72 FD 80 | 	add	objptr, #4
01ab0 6a6 B9 B6 3D 08 | 	wrlong	local01, objptr
01ab4 6a7 04 72 FD 84 | 	sub	objptr, #4
01ab8 6a8 9F A0 BD A0 | 	mov	sp, fp
01abc 6a9 6B EE FC 5C | 	call	#popregs_
01ac0 6aa             | _Float32_stop_ret
01ac0 6aa 3B 84 FC 5C | 	call	#LMM_RET
01ac4 6ab             | 
01ac4 6ab             | '          
01ac4 6ab             | ' PUB FAdd(a, b)
01ac4 6ab             | _Float32_FAdd
01ac4 6ab 00 B8 FC A0 | 	mov	COUNT_, #0
01ac8 6ac 5E D4 FC 5C | 	call	#pushregs_
01acc 6ad 0C A0 FD 80 | 	add	sp, #12
01ad0 6ae 04 3E FD 80 | 	add	fp, #4
01ad4 6af 9F AC 3D 08 | 	wrlong	arg01, fp
01ad8 6b0 04 3E FD 80 | 	add	fp, #4
01adc 6b1 9F AE 3D 08 | 	wrlong	arg02, fp
01ae0 6b2             | ' {{Addition: result = a + b
01ae0 6b2             | '   Returns:   32-bit floating point value}}
01ae0 6b2             | '                         
01ae0 6b2             | '   command := FAddCmd + @a
01ae0 6b2 B3 AE BD A0 | 	mov	arg02, imm_65536_
01ae4 6b3 04 3E FD 84 | 	sub	fp, #4
01ae8 6b4 9F AE BD 80 | 	add	arg02, fp
01aec 6b5 04 72 FD 80 | 	add	objptr, #4
01af0 6b6 B9 AE 3D 08 | 	wrlong	arg02, objptr
01af4 6b7             | '   repeat while command
01af4 6b7 04 3E FD 84 | 	sub	fp, #4
01af8 6b8 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01afc 6b9 08 00 00 00 | 	long	(@@@LR__0093-@@@LR__0092)
01b00 6ba             | LR__0092
01b00 6ba B9 AE BD 0A | 	rdlong	arg02, objptr wz
01b04 6bb E7 00 54 5C |  if_ne	jmp	#LMM_FCACHE_START + (LR__0092 - LR__0092)
01b08 6bc             | LR__0093
01b08 6bc             | '   return cmdReturn
01b08 6bc 04 72 FD 80 | 	add	objptr, #4
01b0c 6bd B9 9E BD 08 | 	rdlong	result1, objptr
01b10 6be 08 72 FD 84 | 	sub	objptr, #8
01b14 6bf 9F A0 BD A0 | 	mov	sp, fp
01b18 6c0 6B EE FC 5C | 	call	#popregs_
01b1c 6c1             | _Float32_FAdd_ret
01b1c 6c1 3B 84 FC 5C | 	call	#LMM_RET
01b20 6c2             | 
01b20 6c2             | '   
01b20 6c2             | ' PUB FMul(a, b)
01b20 6c2             | _Float32_FMul
01b20 6c2 00 B8 FC A0 | 	mov	COUNT_, #0
01b24 6c3 5E D4 FC 5C | 	call	#pushregs_
01b28 6c4 0C A0 FD 80 | 	add	sp, #12
01b2c 6c5 04 3E FD 80 | 	add	fp, #4
01b30 6c6 9F AC 3D 08 | 	wrlong	arg01, fp
01b34 6c7 04 3E FD 80 | 	add	fp, #4
01b38 6c8 9F AE 3D 08 | 	wrlong	arg02, fp
01b3c 6c9             | ' {{Multiplication: result = a * b
01b3c 6c9             | '   Returns:   32-bit floating point value}}
01b3c 6c9             | ' 
01b3c 6c9             | '   command := FMulCmd + @a
01b3c 6c9 A7 AE BD A0 | 	mov	arg02, imm_196608_
01b40 6ca 04 3E FD 84 | 	sub	fp, #4
01b44 6cb 9F AE BD 80 | 	add	arg02, fp
01b48 6cc 04 72 FD 80 | 	add	objptr, #4
01b4c 6cd B9 AE 3D 08 | 	wrlong	arg02, objptr
01b50 6ce             | '   repeat while command
01b50 6ce 04 3E FD 84 | 	sub	fp, #4
01b54 6cf 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01b58 6d0 08 00 00 00 | 	long	(@@@LR__0095-@@@LR__0094)
01b5c 6d1             | LR__0094
01b5c 6d1 B9 AE BD 0A | 	rdlong	arg02, objptr wz
01b60 6d2 E7 00 54 5C |  if_ne	jmp	#LMM_FCACHE_START + (LR__0094 - LR__0094)
01b64 6d3             | LR__0095
01b64 6d3             | '   return cmdReturn
01b64 6d3 04 72 FD 80 | 	add	objptr, #4
01b68 6d4 B9 9E BD 08 | 	rdlong	result1, objptr
01b6c 6d5 08 72 FD 84 | 	sub	objptr, #8
01b70 6d6 9F A0 BD A0 | 	mov	sp, fp
01b74 6d7 6B EE FC 5C | 	call	#popregs_
01b78 6d8             | _Float32_FMul_ret
01b78 6d8 3B 84 FC 5C | 	call	#LMM_RET
01b7c 6d9             | 
01b7c 6d9             | '           
01b7c 6d9             | ' PUB FDiv(a, b)
01b7c 6d9             | _Float32_FDiv
01b7c 6d9 00 B8 FC A0 | 	mov	COUNT_, #0
01b80 6da 5E D4 FC 5C | 	call	#pushregs_
01b84 6db 0C A0 FD 80 | 	add	sp, #12
01b88 6dc 04 3E FD 80 | 	add	fp, #4
01b8c 6dd 9F AC 3D 08 | 	wrlong	arg01, fp
01b90 6de 04 3E FD 80 | 	add	fp, #4
01b94 6df 9F AE 3D 08 | 	wrlong	arg02, fp
01b98 6e0             | ' {{Division: result = a / b
01b98 6e0             | '   Returns:   32-bit floating point value}}
01b98 6e0             | ' 
01b98 6e0             | '   command := FDivCmd + @a
01b98 6e0 AA AE BD A0 | 	mov	arg02, imm_262144_
01b9c 6e1 04 3E FD 84 | 	sub	fp, #4
01ba0 6e2 9F AE BD 80 | 	add	arg02, fp
01ba4 6e3 04 72 FD 80 | 	add	objptr, #4
01ba8 6e4 B9 AE 3D 08 | 	wrlong	arg02, objptr
01bac 6e5             | '   repeat while command
01bac 6e5 04 3E FD 84 | 	sub	fp, #4
01bb0 6e6 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01bb4 6e7 08 00 00 00 | 	long	(@@@LR__0097-@@@LR__0096)
01bb8 6e8             | LR__0096
01bb8 6e8 B9 AE BD 0A | 	rdlong	arg02, objptr wz
01bbc 6e9 E7 00 54 5C |  if_ne	jmp	#LMM_FCACHE_START + (LR__0096 - LR__0096)
01bc0 6ea             | LR__0097
01bc0 6ea             | '   return cmdReturn
01bc0 6ea 04 72 FD 80 | 	add	objptr, #4
01bc4 6eb B9 9E BD 08 | 	rdlong	result1, objptr
01bc8 6ec 08 72 FD 84 | 	sub	objptr, #8
01bcc 6ed 9F A0 BD A0 | 	mov	sp, fp
01bd0 6ee 6B EE FC 5C | 	call	#popregs_
01bd4 6ef             | _Float32_FDiv_ret
01bd4 6ef 3B 84 FC 5C | 	call	#LMM_RET
01bd8 6f0             | 
01bd8 6f0             | ' 
01bd8 6f0             | ' PUB FFloat(n)
01bd8 6f0             | _Float32_FFloat
01bd8 6f0 00 B8 FC A0 | 	mov	COUNT_, #0
01bdc 6f1 5E D4 FC 5C | 	call	#pushregs_
01be0 6f2 08 A0 FD 80 | 	add	sp, #8
01be4 6f3 04 3E FD 80 | 	add	fp, #4
01be8 6f4 9F AC 3D 08 | 	wrlong	arg01, fp
01bec 6f5             | ' {{Convert integer to floating point.
01bec 6f5             | '   Returns:   32-bit floating point value}}
01bec 6f5             | ' 
01bec 6f5             | '   command := FFloatCmd + @n
01bec 6f5 AB AC BD A0 | 	mov	arg01, imm_327680_
01bf0 6f6 9F AC BD 80 | 	add	arg01, fp
01bf4 6f7 04 72 FD 80 | 	add	objptr, #4
01bf8 6f8 B9 AC 3D 08 | 	wrlong	arg01, objptr
01bfc 6f9             | '   repeat while command
01bfc 6f9 04 3E FD 84 | 	sub	fp, #4
01c00 6fa 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01c04 6fb 08 00 00 00 | 	long	(@@@LR__0099-@@@LR__0098)
01c08 6fc             | LR__0098
01c08 6fc B9 AC BD 0A | 	rdlong	arg01, objptr wz
01c0c 6fd E7 00 54 5C |  if_ne	jmp	#LMM_FCACHE_START + (LR__0098 - LR__0098)
01c10 6fe             | LR__0099
01c10 6fe             | '   return cmdReturn  
01c10 6fe 04 72 FD 80 | 	add	objptr, #4
01c14 6ff B9 9E BD 08 | 	rdlong	result1, objptr
01c18 700 08 72 FD 84 | 	sub	objptr, #8
01c1c 701 9F A0 BD A0 | 	mov	sp, fp
01c20 702 6B EE FC 5C | 	call	#popregs_
01c24 703             | _Float32_FFloat_ret
01c24 703 3B 84 FC 5C | 	call	#LMM_RET
01c28 704             | 
01c28 704             | ' 
01c28 704             | ' PUB FTrunc(a)
01c28 704             | _Float32_FTrunc
01c28 704 00 B8 FC A0 | 	mov	COUNT_, #0
01c2c 705 5E D4 FC 5C | 	call	#pushregs_
01c30 706 08 A0 FD 80 | 	add	sp, #8
01c34 707 04 3E FD 80 | 	add	fp, #4
01c38 708 9F AC 3D 08 | 	wrlong	arg01, fp
01c3c 709             | ' {{Convert floating point to integer (with truncation).
01c3c 709             | '   Returns:   32-bit integer value }}
01c3c 709             | ' 
01c3c 709             | '    command := FTruncCmd + @a
01c3c 709 AC AC BD A0 | 	mov	arg01, imm_393216_
01c40 70a 9F AC BD 80 | 	add	arg01, fp
01c44 70b 04 72 FD 80 | 	add	objptr, #4
01c48 70c B9 AC 3D 08 | 	wrlong	arg01, objptr
01c4c 70d             | '   repeat while command
01c4c 70d 04 3E FD 84 | 	sub	fp, #4
01c50 70e 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01c54 70f 08 00 00 00 | 	long	(@@@LR__0101-@@@LR__0100)
01c58 710             | LR__0100
01c58 710 B9 AC BD 0A | 	rdlong	arg01, objptr wz
01c5c 711 E7 00 54 5C |  if_ne	jmp	#LMM_FCACHE_START + (LR__0100 - LR__0100)
01c60 712             | LR__0101
01c60 712             | '   return cmdReturn  
01c60 712 04 72 FD 80 | 	add	objptr, #4
01c64 713 B9 9E BD 08 | 	rdlong	result1, objptr
01c68 714 08 72 FD 84 | 	sub	objptr, #8
01c6c 715 9F A0 BD A0 | 	mov	sp, fp
01c70 716 6B EE FC 5C | 	call	#popregs_
01c74 717             | _Float32_FTrunc_ret
01c74 717 3B 84 FC 5C | 	call	#LMM_RET
01c78 718             | 
01c78 718             | ' 
01c78 718             | ' PUB Sin(a)
01c78 718             | _Float32_Sin
01c78 718 00 B8 FC A0 | 	mov	COUNT_, #0
01c7c 719 5E D4 FC 5C | 	call	#pushregs_
01c80 71a 08 A0 FD 80 | 	add	sp, #8
01c84 71b 04 3E FD 80 | 	add	fp, #4
01c88 71c 9F AC 3D 08 | 	wrlong	arg01, fp
01c8c 71d             | ' {{Sine of an angle. 
01c8c 71d             | '   Returns:   32-bit floating point value}}
01c8c 71d             | ' 
01c8c 71d             | '   command := SinCmd + @a
01c8c 71d B2 AC BD A0 | 	mov	arg01, imm_655360_
01c90 71e 9F AC BD 80 | 	add	arg01, fp
01c94 71f 04 72 FD 80 | 	add	objptr, #4
01c98 720 B9 AC 3D 08 | 	wrlong	arg01, objptr
01c9c 721             | '   repeat while command
01c9c 721 04 3E FD 84 | 	sub	fp, #4
01ca0 722 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01ca4 723 08 00 00 00 | 	long	(@@@LR__0103-@@@LR__0102)
01ca8 724             | LR__0102
01ca8 724 B9 AC BD 0A | 	rdlong	arg01, objptr wz
01cac 725 E7 00 54 5C |  if_ne	jmp	#LMM_FCACHE_START + (LR__0102 - LR__0102)
01cb0 726             | LR__0103
01cb0 726             | '   return cmdReturn  
01cb0 726 04 72 FD 80 | 	add	objptr, #4
01cb4 727 B9 9E BD 08 | 	rdlong	result1, objptr
01cb8 728 08 72 FD 84 | 	sub	objptr, #8
01cbc 729 9F A0 BD A0 | 	mov	sp, fp
01cc0 72a 6B EE FC 5C | 	call	#popregs_
01cc4 72b             | _Float32_Sin_ret
01cc4 72b 3B 84 FC 5C | 	call	#LMM_RET
01cc8 72c             | 
01cc8 72c             | ' 
01cc8 72c             | ' PUB Cos(a)
01cc8 72c             | _Float32_Cos
01cc8 72c 00 B8 FC A0 | 	mov	COUNT_, #0
01ccc 72d 5E D4 FC 5C | 	call	#pushregs_
01cd0 72e 08 A0 FD 80 | 	add	sp, #8
01cd4 72f 04 3E FD 80 | 	add	fp, #4
01cd8 730 9F AC 3D 08 | 	wrlong	arg01, fp
01cdc 731             | ' {{Cosine of an angle.
01cdc 731             | '   Returns:   32-bit floating point value}}
01cdc 731             | ' 
01cdc 731             | '   command := CosCmd + @a
01cdc 731 B4 AC BD A0 | 	mov	arg01, imm_720896_
01ce0 732 9F AC BD 80 | 	add	arg01, fp
01ce4 733 04 72 FD 80 | 	add	objptr, #4
01ce8 734 B9 AC 3D 08 | 	wrlong	arg01, objptr
01cec 735             | '   repeat while command
01cec 735 04 3E FD 84 | 	sub	fp, #4
01cf0 736 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01cf4 737 08 00 00 00 | 	long	(@@@LR__0105-@@@LR__0104)
01cf8 738             | LR__0104
01cf8 738 B9 AC BD 0A | 	rdlong	arg01, objptr wz
01cfc 739 E7 00 54 5C |  if_ne	jmp	#LMM_FCACHE_START + (LR__0104 - LR__0104)
01d00 73a             | LR__0105
01d00 73a             | '   return cmdReturn  
01d00 73a 04 72 FD 80 | 	add	objptr, #4
01d04 73b B9 9E BD 08 | 	rdlong	result1, objptr
01d08 73c 08 72 FD 84 | 	sub	objptr, #8
01d0c 73d 9F A0 BD A0 | 	mov	sp, fp
01d10 73e 6B EE FC 5C | 	call	#popregs_
01d14 73f             | _Float32_Cos_ret
01d14 73f 3B 84 FC 5C | 	call	#LMM_RET
01d18 740             | hubexit
01d18 740 05 00 7C 5C | 	jmp	#cogexit
01d1c 741             | 
01d1c 741             | __system___coginit
01d1c 741 B1 B0 BD 60 | 	and	arg03, imm_65532_
01d20 742 10 B0 FD 2C | 	shl	arg03, #16
01d24 743 B1 AE BD 60 | 	and	arg02, imm_65532_
01d28 744 02 AE FD 2C | 	shl	arg02, #2
01d2c 745 D7 B0 BD 68 | 	or	arg03, arg02
01d30 746 0F AC FD 60 | 	and	arg01, #15
01d34 747 D6 B0 BD 68 | 	or	arg03, arg01
01d38 748 02 B0 FD 0D | 	coginit	arg03 wc,wr
01d3c 749 01 B0 F1 A4 |  if_b	neg	arg03, #1
01d40 74a D8 9E BD A0 | 	mov	result1, arg03
01d44 74b             | __system___coginit_ret
01d44 74b 3B 84 FC 5C | 	call	#LMM_RET
01d48 74c             | 
01d48 74c             | __system____builtin_memmove
01d48 74c D6 A2 BD A0 | 	mov	_var01, arg01
01d4c 74d D7 AC 3D C1 | 	cmps	arg01, arg02 wc
01d50 74e 28 5E CC 80 |  if_ae	add	pc, #4*(LR__0108 - ($+1))
01d54 74f D8 A4 BD A2 | 	mov	_var02, arg03 wz
01d58 750 4C 5E E8 80 |  if_e	add	pc, #4*(LR__0112 - ($+1))
01d5c 751 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01d60 752 14 00 00 00 | 	long	(@@@LR__0107-@@@LR__0106)
01d64 753             | LR__0106
01d64 753 D7 9E BD 00 | 	rdbyte	result1, arg02
01d68 754 D6 9E 3D 00 | 	wrbyte	result1, arg01
01d6c 755 01 AC FD 80 | 	add	arg01, #1
01d70 756 01 AE FD 80 | 	add	arg02, #1
01d74 757 E7 A4 FD E4 | 	djnz	_var02, #LMM_FCACHE_START + (LR__0106 - LR__0106)
01d78 758             | LR__0107
01d78 758 2C 5E FC 80 | 	add	pc, #4*(LR__0112 - ($+1))
01d7c 759             | LR__0108
01d7c 759 D8 AC BD 80 | 	add	arg01, arg03
01d80 75a D8 AE BD 80 | 	add	arg02, arg03
01d84 75b D8 A6 BD A2 | 	mov	_var03, arg03 wz
01d88 75c 1C 5E E8 80 |  if_e	add	pc, #4*(LR__0111 - ($+1))
01d8c 75d 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01d90 75e 14 00 00 00 | 	long	(@@@LR__0110-@@@LR__0109)
01d94 75f             | LR__0109
01d94 75f 01 AC FD 84 | 	sub	arg01, #1
01d98 760 01 AE FD 84 | 	sub	arg02, #1
01d9c 761 D7 A8 BD 00 | 	rdbyte	_var04, arg02
01da0 762 D6 A8 3D 00 | 	wrbyte	_var04, arg01
01da4 763 E7 A6 FD E4 | 	djnz	_var03, #LMM_FCACHE_START + (LR__0109 - LR__0109)
01da8 764             | LR__0110
01da8 764             | LR__0111
01da8 764             | LR__0112
01da8 764 D1 9E BD A0 | 	mov	result1, _var01
01dac 765             | __system____builtin_memmove_ret
01dac 765 3B 84 FC 5C | 	call	#LMM_RET
01db0 766             | 
01db0 766             | __system__longmove
01db0 766 D6 A2 BD A0 | 	mov	_var01, arg01
01db4 767 D7 AC 3D C1 | 	cmps	arg01, arg02 wc
01db8 768 28 5E CC 80 |  if_ae	add	pc, #4*(LR__0115 - ($+1))
01dbc 769 D8 A4 BD A2 | 	mov	_var02, arg03 wz
01dc0 76a 5C 5E E8 80 |  if_e	add	pc, #4*(LR__0119 - ($+1))
01dc4 76b 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01dc8 76c 14 00 00 00 | 	long	(@@@LR__0114-@@@LR__0113)
01dcc 76d             | LR__0113
01dcc 76d D7 9E BD 08 | 	rdlong	result1, arg02
01dd0 76e D6 9E 3D 08 | 	wrlong	result1, arg01
01dd4 76f 04 AC FD 80 | 	add	arg01, #4
01dd8 770 04 AE FD 80 | 	add	arg02, #4
01ddc 771 E7 A4 FD E4 | 	djnz	_var02, #LMM_FCACHE_START + (LR__0113 - LR__0113)
01de0 772             | LR__0114
01de0 772 3C 5E FC 80 | 	add	pc, #4*(LR__0119 - ($+1))
01de4 773             | LR__0115
01de4 773 D8 A6 BD A0 | 	mov	_var03, arg03
01de8 774 02 A6 FD 2C | 	shl	_var03, #2
01dec 775 D3 AC BD 80 | 	add	arg01, _var03
01df0 776 D8 A6 BD A0 | 	mov	_var03, arg03
01df4 777 02 A6 FD 2C | 	shl	_var03, #2
01df8 778 D3 AE BD 80 | 	add	arg02, _var03
01dfc 779 D8 A8 BD A2 | 	mov	_var04, arg03 wz
01e00 77a 1C 5E E8 80 |  if_e	add	pc, #4*(LR__0118 - ($+1))
01e04 77b 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01e08 77c 14 00 00 00 | 	long	(@@@LR__0117-@@@LR__0116)
01e0c 77d             | LR__0116
01e0c 77d 04 AC FD 84 | 	sub	arg01, #4
01e10 77e 04 AE FD 84 | 	sub	arg02, #4
01e14 77f D7 AA BD 08 | 	rdlong	_var05, arg02
01e18 780 D6 AA 3D 08 | 	wrlong	_var05, arg01
01e1c 781 E7 A8 FD E4 | 	djnz	_var04, #LMM_FCACHE_START + (LR__0116 - LR__0116)
01e20 782             | LR__0117
01e20 782             | LR__0118
01e20 782             | LR__0119
01e20 782 D1 9E BD A0 | 	mov	result1, _var01
01e24 783             | __system__longmove_ret
01e24 783 3B 84 FC 5C | 	call	#LMM_RET
01e28 784             | 
01e28 784             | __system____builtin_strlen
01e28 784 00 A2 FD A0 | 	mov	_var01, #0
01e2c 785 43 AC FC 5C | 	call	#LMM_FCACHE_LOAD
01e30 786 10 00 00 00 | 	long	(@@@LR__0121-@@@LR__0120)
01e34 787             | LR__0120
01e34 787 D6 9E BD 02 | 	rdbyte	result1, arg01 wz
01e38 788 01 A2 D5 80 |  if_ne	add	_var01, #1
01e3c 789 01 AC D5 80 |  if_ne	add	arg01, #1
01e40 78a E7 00 54 5C |  if_ne	jmp	#LMM_FCACHE_START + (LR__0120 - LR__0120)
01e44 78b             | LR__0121
01e44 78b D1 9E BD A0 | 	mov	result1, _var01
01e48 78c             | __system____builtin_strlen_ret
01e48 78c 3B 84 FC 5C | 	call	#LMM_RET
01e4c 78d             | 
01e4c 78d             | LR__0122
01e4c 78d 74 69 74 6C 
01e50 78e 65          | 	byte	"title"
01e51 78e 00          | 	byte	0
01e52 78e             | LR__0123
01e52 78e 53 69 6E 65 
01e56 78f 20 61 6E 64 
01e5a 790 20 43 6F 73 
01e5e 791 69 6E 65 20 
01e62 792 57 61 76 65 
01e66 793 66 6F 72 6D 
01e6a 794 73          | 	byte	"Sine and Cosine Waveforms"
01e6b 794 00          | 	byte	0
01e6c 795             | LR__0124
01e6c 795 78 2D 6C 61 
01e70 796 62 65 6C    | 	byte	"x-label"
01e73 796 00          | 	byte	0
01e74 797             | LR__0125
01e74 797 54 69 6D 65 | 	byte	"Time"
01e78 798 00          | 	byte	0
01e79 798             | LR__0126
01e79 798 79 2D 6C 61 
01e7d 799 62 65 6C    | 	byte	"y-label"
01e80 79a 00          | 	byte	0
01e81 79a             | LR__0127
01e81 79a 41 6D 70 6C 
01e85 79b 69 74 75 64 
01e89 79c 65          | 	byte	"Amplitude"
01e8a 79c 00          | 	byte	0
01e8b 79c             | LR__0128
01e8b 79c 53 69 6E 65 
01e8f 79d 77 61 76 65 | 	byte	"Sinewave"
01e93 79e 00          | 	byte	0
01e94 79f             | LR__0129
01e94 79f 43 6F 73 69 
01e98 7a0 6E 65 77 61 
01e9c 7a1 76 65       | 	byte	"Cosinewave"
01e9e 7a1 00          | 	byte	0
01e9f 7a1             | LR__0130
01e9f 7a1 53 69 6E 65 
01ea3 7a2 77 61 76 65 | 	byte	"Sinewave"
01ea7 7a3 00          | 	byte	0
01ea8 7a4             | LR__0131
01ea8 7a4 43 6F 73 69 
01eac 7a5 6E 65 77 61 
01eb0 7a6 76 65       | 	byte	"Cosinewave"
01eb2 7a6 00          | 	byte	0
01eb3 7a6             | LR__0132
01eb3 7a6 7B 54 49 4D 
01eb7 7a7 45 50 4C 4F 
01ebb 7a8 54 7C 53 45 
01ebf 7a9 54 7C       | 	byte	"{TIMEPLOT|SET|"
01ec1 7aa 00          | 	byte	0
01ec2 7aa             | LR__0133
01ec2 7aa 7B 54 49 4D 
01ec6 7ab 45 50 4C 4F 
01eca 7ac 54 7C 53 54 
01ece 7ad 59 4C 45 7C | 	byte	"{TIMEPLOT|STYLE|"
01ed2 7ae 00          | 	byte	0
01ed3 7ae             | LR__0134
01ed3 7ae 7B 54 49 4D 
01ed7 7af 45 50 4C 4F 
01edb 7b0 54 7C 44 41 
01edf 7b1 54 41 7C    | 	byte	"{TIMEPLOT|DATA|"
01ee2 7b2 00          | 	byte	0
01ee3 7b2             | LR__0135
01ee3 7b2 7C 54 7C    | 	byte	"|T|"
01ee6 7b3 00          | 	byte	0
01ee7 7b3             | LR__0136
01ee7 7b3 7B 54 49 4D 
01eeb 7b4 45 50 4C 4F 
01eef 7b5 54 7C 44 41 
01ef3 7b6 54 41 7C    | 	byte	"{TIMEPLOT|DATA|"
01ef6 7b7 00          | 	byte	0
01ef7 7b7             | LR__0137
01ef7 7b7 7C 54 7C    | 	byte	"|T|"
01efa 7b8 00          | 	byte	0
01efb 7b8 00          | 	long
01efc 7b9             | _FullDuplexSerialAvail_dat_
01efc 7b9             | 
01efc 7b9             | '***********************************
01efc 7b9             | '* Assembly language serial driver *
01efc 7b9             | '***********************************
01efc 7b9             | 
01efc 7b9             |                         org
01efc 000             | '
01efc 000             | '
01efc 000             | ' Entry
01efc 000             | '
01efc 000 F0 A9 BC A0 | entry                   mov     t1,par                'get structure address
01f00 001 10 A8 FC 80 |                         add     t1,#4 << 2            'skip past heads and tails
01f04 002             | 
01f04 002 54 AA BC 08 |                         rdlong  t2,t1                 'get rx_pin
01f08 003 01 B2 FC A0 |                         mov     rxmask,#1
01f0c 004 55 B2 BC 2C |                         shl     rxmask,t2
01f10 005             | 
01f10 005 04 A8 FC 80 |                         add     t1,#4                 'get tx_pin
01f14 006 54 AA BC 08 |                         rdlong  t2,t1
01f18 007 01 BE FC A0 |                         mov     txmask,#1
01f1c 008 55 BE BC 2C |                         shl     txmask,t2
01f20 009             | 
01f20 009 04 A8 FC 80 |                         add     t1,#4                 'get rxtx_mode
01f24 00a 54 AE BC 08 |                         rdlong  rxtxmode,t1
01f28 00b             | 
01f28 00b 04 A8 FC 80 |                         add     t1,#4                 'get bit_ticks
01f2c 00c 54 B0 BC 08 |                         rdlong  bitticks,t1
01f30 00d             | 
01f30 00d 04 A8 FC 80 |                         add     t1,#4                 'get buffer_ptr
01f34 00e 54 B4 BC 08 |                         rdlong  rxbuff,t1
01f38 00f 5A C0 BC A0 |                         mov     txbuff,rxbuff
01f3c 010 10 C0 FC 80 |                         add     txbuff,#16
01f40 011             | 
01f40 011 04 AE 7C 62 |                         test    rxtxmode,#%100  wz    'init tx pin according to mode
01f44 012 02 AE 7C 61 |                         test    rxtxmode,#%010  wc
01f48 013 5F E8 9B 68 |         if_z_ne_c       or      outa,txmask
01f4c 014 5F EC AB 68 |         if_z            or      dira,txmask
01f50 015             | 
01f50 015 33 C8 FC A0 |                         mov     txcode,#transmit      'initialize ping-pong multitasking
01f54 016             | '
01f54 016             | '
01f54 016             | ' Receive
01f54 016             | '
01f54 016 64 BC BC 5C | receive                 jmpret  rxcode,txcode         'run a chunk of transmit code, then return
01f58 017             | 
01f58 017 01 AE 7C 62 |                         test    rxtxmode,#%001  wz    'wait for start bit on rx pin
01f5c 018 F2 B3 3C 61 |                         test    rxmask,ina      wc
01f60 019 16 00 64 5C |         if_z_eq_c       jmp     #receive
01f64 01a             | 
01f64 01a 09 B8 FC A0 |                         mov     rxbits,#9             'ready to receive byte
01f68 01b 58 BA BC A0 |                         mov     rxcnt,bitticks
01f6c 01c 01 BA FC 28 |                         shr     rxcnt,#1
01f70 01d F1 BB BC 80 |                         add     rxcnt,cnt
01f74 01e             | 
01f74 01e 58 BA BC 80 | :bit                    add     rxcnt,bitticks        'ready next bit period
01f78 01f             | 
01f78 01f 64 BC BC 5C | :wait                   jmpret  rxcode,txcode         'run a chuck of transmit code, then return
01f7c 020             | 
01f7c 020 5D A8 BC A0 |                         mov     t1,rxcnt              'check if bit receive period done
01f80 021 F1 A9 BC 84 |                         sub     t1,cnt
01f84 022 00 A8 7C C1 |                         cmps    t1,#0           wc
01f88 023 1F 00 4C 5C |         if_nc           jmp     #:wait
01f8c 024             | 
01f8c 024 F2 B3 3C 61 |                         test    rxmask,ina      wc    'receive bit on rx pin
01f90 025 01 B6 FC 30 |                         rcr     rxdata,#1
01f94 026 1E B8 FC E4 |                         djnz    rxbits,#:bit
01f98 027             | 
01f98 027 17 B6 FC 28 |                         shr     rxdata,#32-9          'justify and trim received byte
01f9c 028 FF B6 FC 60 |                         and     rxdata,#$FF
01fa0 029 01 AE 7C 62 |                         test    rxtxmode,#%001  wz    'if rx inverted, invert byte
01fa4 02a FF B6 D4 6C |         if_nz           xor     rxdata,#$FF
01fa8 02b             | 
01fa8 02b F0 AB BC 08 |                         rdlong  t2,par                'save received byte and inc head
01fac 02c 5A AA BC 80 |                         add     t2,rxbuff
01fb0 02d 55 B6 3C 00 |                         wrbyte  rxdata,t2
01fb4 02e 5A AA BC 84 |                         sub     t2,rxbuff
01fb8 02f 01 AA FC 80 |                         add     t2,#1
01fbc 030 0F AA FC 60 |                         and     t2,#$0F
01fc0 031 F0 AB 3C 08 |                         wrlong  t2,par
01fc4 032             | 
01fc4 032 16 00 7C 5C |                         jmp     #receive              'byte done, receive next byte
01fc8 033             | '
01fc8 033             | '
01fc8 033             | ' Transmit
01fc8 033             | '
01fc8 033 5E C8 BC 5C | transmit                jmpret  txcode,rxcode         'run a chunk of receive code, then return
01fcc 034             | 
01fcc 034 F0 A9 BC A0 |                         mov     t1,par                'check for head <> tail
01fd0 035 08 A8 FC 80 |                         add     t1,#2 << 2
01fd4 036 54 AA BC 08 |                         rdlong  t2,t1
01fd8 037 04 A8 FC 80 |                         add     t1,#1 << 2
01fdc 038 54 AC BC 08 |                         rdlong  t3,t1
01fe0 039 56 AA 3C 86 |                         cmp     t2,t3           wz
01fe4 03a 33 00 68 5C |         if_z            jmp     #transmit
01fe8 03b             | 
01fe8 03b 60 AC BC 80 |                         add     t3,txbuff             'get byte and inc tail
01fec 03c 56 C2 BC 00 |                         rdbyte  txdata,t3
01ff0 03d 60 AC BC 84 |                         sub     t3,txbuff
01ff4 03e 01 AC FC 80 |                         add     t3,#1
01ff8 03f 0F AC FC 60 |                         and     t3,#$0F
01ffc 040 54 AC 3C 08 |                         wrlong  t3,t1
02000 041             | 
02000 041 00 C3 FC 68 |                         or      txdata,#$100          'ready byte to transmit
02004 042 02 C2 FC 2C |                         shl     txdata,#2
02008 043 01 C2 FC 68 |                         or      txdata,#1
0200c 044 0B C4 FC A0 |                         mov     txbits,#11
02010 045 F1 C7 BC A0 |                         mov     txcnt,cnt
02014 046             | 
02014 046 04 AE 7C 62 | :bit                    test    rxtxmode,#%100  wz    'output bit on tx pin according to mode
02018 047 02 AE 7C 61 |                         test    rxtxmode,#%010  wc
0201c 048 01 C2 E0 6C |         if_z_and_c      xor     txdata,#1
02020 049 01 C2 FC 29 |                         shr     txdata,#1       wc
02024 04a 5F E8 AB 70 |         if_z            muxc    outa,txmask
02028 04b 5F EC 97 74 |         if_nz           muxnc   dira,txmask
0202c 04c 58 C6 BC 80 |                         add     txcnt,bitticks        'ready next cnt
02030 04d             | 
02030 04d 5E C8 BC 5C | :wait                   jmpret  txcode,rxcode         'run a chunk of receive code, then return
02034 04e             | 
02034 04e 63 A8 BC A0 |                         mov     t1,txcnt              'check if bit transmit period done
02038 04f F1 A9 BC 84 |                         sub     t1,cnt
0203c 050 00 A8 7C C1 |                         cmps    t1,#0           wc
02040 051 4D 00 4C 5C |         if_nc           jmp     #:wait
02044 052             | 
02044 052 46 C4 FC E4 |                         djnz    txbits,#:bit          'another bit to transmit?
02048 053             | 
02048 053 33 00 7C 5C |                         jmp     #transmit             'byte done, transmit next byte
0204c 054             | '
0204c 054             | '
0204c 054             | ' Uninitialized data
0204c 054             | '
0204c 054             | t1                      res     1
0204c 054             | t1                      res     1
0204c 054             | t2                      res     1
0204c 054             | t2                      res     1
0204c 054             | t3                      res     1
0204c 054             | t3                      res     1
0204c 054             | 
0204c 054             | rxtxmode                res     1
0204c 054             | rxtxmode                res     1
0204c 054             | bitticks                res     1
0204c 054             | bitticks                res     1
0204c 054             | 
0204c 054             | rxmask                  res     1
0204c 054             | rxmask                  res     1
0204c 054             | rxbuff                  res     1
0204c 054             | rxbuff                  res     1
0204c 054             | rxdata                  res     1
0204c 054             | rxdata                  res     1
0204c 054             | rxbits                  res     1
0204c 054             | rxbits                  res     1
0204c 054             | rxcnt                   res     1
0204c 054             | rxcnt                   res     1
0204c 054             | rxcode                  res     1
0204c 054             | rxcode                  res     1
0204c 054             | 
0204c 054             | txmask                  res     1
0204c 054             | txmask                  res     1
0204c 054             | txbuff                  res     1
0204c 054             | txbuff                  res     1
0204c 054             | txdata                  res     1
0204c 054             | txdata                  res     1
0204c 054             | txbits                  res     1
0204c 054             | txbits                  res     1
0204c 054             | txcnt                   res     1
0204c 054             | txcnt                   res     1
0204c 054             | txcode                  res     1
0204c 054             | txcode                  res     1
0204c 054             | _Numbers_dat_
0204c 054 2C 5F 24 25 
02050 055 78 78 78 00 |   DefaultSymbols        byte    ",_$%xxx"                                                               'Special, default, symbols ("x" means unused)
02054 056             | 	long
02054 056             | _FloatString_dat_
02054 056 99 76 96 7E 
02058 057 C2 BD F0 7C 
0205c 058 CE 97 40 7B 
02060 059 0C 13 9A 79 |         long                1e+38, 1e+37, 1e+36, 1e+35, 1e+34, 1e+33, 1e+32, 1e+31
02064 05a DF 84 F6 77 
02068 05b 19 37 45 76 
0206c 05c AE C5 9D 74 
02070 05d 7C 6F FC 72 | 	byte	$df, $84, $f6, $77, $19, $37, $45, $76, $ae, $c5, $9d, $74, $7c, $6f, $fc, $72
02074 05e CA F2 49 71 
02078 05f 08 8F A1 6F 
0207c 060 39 3F 01 6E 
02080 061 8F CB 4E 6C |         long  1e+30, 1e+29, 1e+28, 1e+27, 1e+26, 1e+25, 1e+24, 1e+23, 1e+22, 1e+21
02084 062 A6 6F A5 6A 
02088 063 51 59 04 69 
0208c 064 1C C2 53 67 
02090 065 16 68 A9 65 | 	byte	$a6, $6f, $a5, $6a, $51, $59, $04, $69, $1c, $c2, $53, $67, $16, $68, $a9, $65
02094 066 78 86 07 64 
02098 067 27 D7 58 62 | 	byte	$78, $86, $07, $64, $27, $d7, $58, $62
0209c 068 EC 78 AD 60 
020a0 069 23 C7 0A 5F 
020a4 06a 6B 0B 5E 5D 
020a8 06b BC A2 B1 5B |         long  1e+20, 1e+19, 1e+18, 1e+17, 1e+16, 1e+15, 1e+14, 1e+13, 1e+12, 1e+11
020ac 06c CA 1B 0E 5A 
020b0 06d A9 5F 63 58 
020b4 06e 21 E6 B5 56 
020b8 06f E7 84 11 55 | 	byte	$ca, $1b, $0e, $5a, $a9, $5f, $63, $58, $21, $e6, $b5, $56, $e7, $84, $11, $55
020bc 070 A5 D4 68 53 
020c0 071 B7 43 BA 51 | 	byte	$a5, $d4, $68, $53, $b7, $43, $ba, $51
020c4 072 F9 02 15 50 
020c8 073 28 6B 6E 4E 
020cc 074 20 BC BE 4C 
020d0 075 80 96 18 4B |         long  1e+10, 1e+09, 1e+08, 1e+07, 1e+06, 1e+05, 1e+04, 1e+03, 1e+02, 1e+01
020d4 076 00 24 74 49 
020d8 077 00 50 C3 47 
020dc 078 00 40 1C 46 
020e0 079 00 00 7A 44 | 	byte	$00, $24, $74, $49, $00, $50, $c3, $47, $00, $40, $1c, $46, $00, $00, $7a, $44
020e4 07a 00 00 C8 42 
020e8 07b 00 00 20 41 | 	byte	$00, $00, $c8, $42, $00, $00, $20, $41
020ec 07c 00 00 80 3F 
020f0 07d CD CC CC 3D 
020f4 07e 0A D7 23 3C 
020f8 07f 6F 12 83 3A | tenf    long  1e+00, 1e-01, 1e-02, 1e-03, 1e-04, 1e-05, 1e-06, 1e-07, 1e-08, 1e-09
020fc 080 17 B7 D1 38 
02100 081 AC C5 27 37 
02104 082 BD 37 86 35 
02108 083 95 BF D6 33 | 	byte	$17, $b7, $d1, $38, $ac, $c5, $27, $37, $bd, $37, $86, $35, $95, $bf, $d6, $33
0210c 084 77 CC 2B 32 
02110 085 5F 70 89 30 | 	byte	$77, $cc, $2b, $32, $5f, $70, $89, $30
02114 086 FF E6 DB 2E 
02118 087 FF EB 2F 2D 
0211c 088 CC BC 8C 2B 
02120 089 13 2E E1 29 |         long  1e-10, 1e-11, 1e-12, 1e-13, 1e-14, 1e-15, 1e-16, 1e-17, 1e-18, 1e-19
02124 08a DC 24 34 28 
02128 08b 7D 1D 90 26 
0212c 08c 95 95 E6 24 
02130 08d AA 77 38 23 | 	byte	$dc, $24, $34, $28, $7d, $1d, $90, $26, $95, $95, $e6, $24, $aa, $77, $38, $23
02134 08e EF 92 93 21 
02138 08f 4A 1E EC 1F | 	byte	$ef, $92, $93, $21, $4a, $1e, $ec, $1f
0213c 090 08 E5 3C 1E 
02140 091 A0 1D 97 1C 
02144 092 01 C9 F1 1A 
02148 093 9A 6D 41 19 |         long  1e-20, 1e-21, 1e-22, 1e-23, 1e-24, 1e-25, 1e-26, 1e-27, 1e-28, 1e-29
0214c 094 15 BE 9A 17 
02150 095 88 96 F7 15 
02154 096 06 12 46 14 
02158 097 D2 74 9E 12 | 	byte	$15, $be, $9a, $17, $88, $96, $f7, $15, $06, $12, $46, $14, $d2, $74, $9e, $12
0215c 098 B6 87 FD 10 
02160 099 F8 D2 4A 0F | 	byte	$b6, $87, $fd, $10, $f8, $d2, $4a, $0f
02164 09a 60 42 A2 0D 
02168 09b B3 CE 01 0C 
0216c 09c 1F B1 4F 0A 
02170 09d 4C 27 A6 08 |         long  1e-30, 1e-31, 1e-32, 1e-33, 1e-34, 1e-35, 1e-36, 1e-37, 1e-38
02174 09e 3D EC 04 07 
02178 09f 2E AD 54 05 
0217c 0a0 25 24 AA 03 
02180 0a1 EA 1C 08 02 | 	byte	$3d, $ec, $04, $07, $2e, $ad, $54, $05, $25, $24, $aa, $03, $ea, $1c, $08, $02
02184 0a2 EE E3 6C 00 | 	byte	$ee, $e3, $6c, $00
02188 0a3             | 
02188 0a3 01 00 00 00 
0218c 0a4 0A 00 00 00 
02190 0a5 64 00 00 00 
02194 0a6 E8 03 00 00 | teni    long  1, 10, 100, 1_000, 10_000, 100_000, 1_000_000, 10_000_000
02198 0a7 10 27 00 00 
0219c 0a8 A0 86 01 00 
021a0 0a9 40 42 0F 00 
021a4 0aa 80 96 98 00 | 	byte	$10, $27, $00, $00, $a0, $86, $01, $00, $40, $42, $0f, $00, $80, $96, $98, $00
021a8 0ab             | 
021a8 0ab 79 7A 61 66 
021ac 0ac 70 6E 75 6D |         byte "yzafpnum"
021b0 0ad 00          | metric  byte 0
021b1 0ad 6B 4D 47 54 
021b5 0ae 50 45 5A 59 
021b9 0af 00 00 00    |         byte "kMGTPEZY"
021bc 0b0             | 	long
021bc 0b0             | _Float32_dat_
021bc 0b0             | 
021bc 0b0             | '---------------------------
021bc 0b0             | ' Assembly language routines
021bc 0b0             | '---------------------------
021bc 0b0             |                         org
021bc 000             | 
021bc 000 F0 B3 BF 0A | getCommand              rdlong  t1, par wz              ' wait for command
021c0 001 00 00 68 5C |           if_z          jmp     #getCommand
021c4 002             | 
021c4 002 D9 B5 BF A0 |                         mov     t2, t1                  ' load fnumA
021c8 003 DA C5 BF 08 |                         rdlong  fnumA, t2
021cc 004 04 B4 FF 80 |                         add     t2, #4          
021d0 005 DA CD BF 08 |                         rdlong  fnumB, t2               ' load fnumB
021d4 006             | 
021d4 006 10 B2 FF 2A |                         shr     t1, #16 wz              ' get command
021d8 007 13 B2 7F 85 |                         cmp     t1, #(FracCmd>>16)+1 wc ' check for valid command
021dc 008 30 00 6C 5C |           if_z_or_nc    jmp     #:exitNaN 
021e0 009 01 B2 FF 2C |                         shl     t1, #1
021e4 00a 0A B2 FF 80 |                         add     t1, #:cmdTable-2 
021e8 00b D9 01 3C 5C |                         jmp     t1                      ' jump to command
021ec 00c             | 
021ec 00c 41 AA FC 5C | :cmdTable               call    #_FAdd                  ' command dispatch table
021f0 00d 31 00 7C 5C |                         jmp     #endCommand
021f4 00e 3C AA FC 5C |                         call    #_FSub
021f8 00f 31 00 7C 5C |                         jmp     #endCommand
021fc 010 59 CE FC 5C |                         call    #_FMul
02200 011 31 00 7C 5C |                         jmp     #endCommand
02204 012 6B F4 FC 5C |                         call    #_FDiv
02208 013 31 00 7C 5C |                         jmp     #endCommand
0220c 014 7B 0E FD 5C |                         call    #_FFloat
02210 015 31 00 7C 5C |                         jmp     #endCommand
02214 016 88 30 FD 5C |                         call    #_FTrunc
02218 017 31 00 7C 5C |                         jmp     #endCommand
0221c 018 8A 30 FD 5C |                         call    #_FRound
02220 019 31 00 7C 5C |                         jmp     #endCommand
02224 01a 99 68 FD 5C |                         call    #_FSqr
02228 01b 31 00 7C 5C |                         jmp     #endCommand
0222c 01c 36 70 FC 5C |                         call    #cmd_FCmp
02230 01d 31 00 7C 5C |                         jmp     #endCommand
02234 01e CD F8 FD 5C |                         call    #_Sin
02238 01f 31 00 7C 5C |                         jmp     #endCommand
0223c 020 CB F8 FD 5C |                         call    #_Cos
02240 021 31 00 7C 5C |                         jmp     #endCommand
02244 022 FD 08 FE 5C |                         call    #_Tan
02248 023 31 00 7C 5C |                         jmp     #endCommand
0224c 024 05 11 FE 5C |                         call    #_Log
02250 025 31 00 7C 5C |                         jmp     #endCommand
02254 026 09 19 FE 5C |                         call    #_Log10
02258 027 31 00 7C 5C |                         jmp     #endCommand
0225c 028 20 85 FE 5C |                         call    #_Exp
02260 029 31 00 7C 5C |                         jmp     #endCommand
02264 02a 23 85 FE 5C |                         call    #_Exp10
02268 02b 31 00 7C 5C |                         jmp     #endCommand
0226c 02c 43 C1 FE 5C |                         call    #_Pow
02270 02d 31 00 7C 5C |                         jmp     #endCommand
02274 02e 61 D5 FE 5C |                         call    #_Frac
02278 02f 31 00 7C 5C |                         jmp     #endCommand
0227c 030             | :cmdTableEnd
0227c 030             | 
0227c 030 CB C5 BF A0 | :exitNaN                mov     fnumA, NaN              ' unknown command
02280 031             | 
02280 031 F0 B3 BF A0 | endCommand              mov     t1, par                 ' return result
02284 032 04 B2 FF 80 |                         add     t1, #4
02288 033 D9 C5 3F 08 |                         wrlong  fnumA, t1
0228c 034 F0 93 3F 08 |                         wrlong  Zero,par                ' clear command status
02290 035 00 00 7C 5C |                         jmp     #getCommand             ' wait for next command
02294 036             | 
02294 036             | '------------------------------------------------------------------------------
02294 036             | 
02294 036 B8 94 FD 5C | cmd_FCmp                call    #_FCmp                  ' compare fnumA and fnumB
02298 037 E1 C5 BF A0 |                         mov     fnumA, status           ' return compare status
0229c 038 00 00 7C 5C | cmd_FCmp_ret            ret
022a0 039             | 
022a0 039             | '------------------------------------------------------------------------------
022a0 039             | ' _FAdd    fnumA = fnumA + fNumB
022a0 039             | ' _FAddI   fnumA = fnumA + {Float immediate}
022a0 039             | ' _FSub    fnumA = fnumA - fNumB
022a0 039             | ' _FSubI   fnumA = fnumA - {Float immediate}
022a0 039             | ' changes: fnumA, flagA, expA, manA, fnumB, flagB, expB, manB, t1
022a0 039             | '------------------------------------------------------------------------------
022a0 039             | 
022a0 039 55 76 BC 50 | _FSubI                  movs    :getB, _FSubI_ret       ' get immediate value
022a4 03a 01 AA FC 80 |                         add     _FSubI_ret, #1
022a8 03b 00 CC BF A0 | :getB                   mov     fnumB, 0
022ac 03c             | 
022ac 03c D2 CD BF 6C | _FSub                   xor     fnumB, Bit31            ' negate B
022b0 03d 41 00 7C 5C |                         jmp     #_FAdd                  ' add values                                               
022b4 03e             | 
022b4 03e 55 80 BC 50 | _FAddI                  movs    :getB, _FAddI_ret       ' get immediate value
022b8 03f 01 AA FC 80 |                         add     _FAddI_ret, #1
022bc 040 00 CC BF A0 | :getB                   mov     fnumB, 0
022c0 041             | 
022c0 041 86 23 FF 5C | _FAdd                   call    #_Unpack2               ' unpack two variables                    
022c4 042 55 00 78 5C |           if_c_or_z     jmp     #_FAdd_ret              ' check for NaN or B = 0
022c8 043             | 
022c8 043 01 C6 7F 62 |                         test    flagA, #SignFlag wz     ' negate A mantissa if negative
022cc 044 E5 CB 97 A4 |           if_nz         neg     manA, manA
022d0 045 01 CE 7F 62 |                         test    flagB, #SignFlag wz     ' negate B mantissa if negative
022d4 046 E9 D3 97 A4 |           if_nz         neg     manB, manB
022d8 047             | 
022d8 047 E4 B3 BF A0 |                         mov     t1, expA                ' align mantissas
022dc 048 E8 B3 BF 84 |                         sub     t1, expB
022e0 049 D9 B3 BF A8 |                         abs     t1, t1
022e4 04a 1F B2 FF 4C |                         max     t1, #31
022e8 04b E8 C9 3F C3 |                         cmps    expA, expB wz,wc
022ec 04c D9 D3 87 38 |           if_nz_and_nc  sar     manB, t1
022f0 04d D9 CB 93 38 |           if_nz_and_c   sar     manA, t1
022f4 04e E8 C9 93 A0 |           if_nz_and_c   mov     expA, expB        
022f8 04f             | 
022f8 04f E9 CB BF 80 |                         add     manA, manB              ' add the two mantissas
022fc 050 00 CA 7F C1 |                         cmps    manA, #0 wc, nr         ' set sign of result
02300 051 01 C6 F3 68 |           if_c          or      flagA, #SignFlag
02304 052 01 C6 CF 64 |           if_nc         andn    flagA, #SignFlag
02308 053 E5 CB BF A8 |                         abs     manA, manA              ' pack result and exit
0230c 054 B0 91 FF 5C |                         call    #_Pack  
02310 055             | _FSubI_ret
02310 055             | _FSub_ret 
02310 055             | _FAddI_ret
02310 055 00 00 7C 5C | _FAdd_ret               ret      
02314 056             | 
02314 056             | '------------------------------------------------------------------------------
02314 056             | ' _FMul    fnumA = fnumA * fNumB
02314 056             | ' _FMulI   fnumA = fnumA * {Float immediate}
02314 056             | ' changes: fnumA, flagA, expA, manA, fnumB, flagB, expB, manB, t1, t2
02314 056             | '------------------------------------------------------------------------------
02314 056             | 
02314 056 67 B0 BC 50 | _FMulI                  movs    :getB, _FMulI_ret       ' get immediate value
02318 057 01 CE FC 80 |                         add     _FMulI_ret, #1
0231c 058 00 CC BF A0 | :getB                   mov     fnumB, 0
02320 059             | 
02320 059 86 23 FF 5C | _FMul                   call    #_Unpack2               ' unpack two variables
02324 05a 67 00 70 5C |           if_c          jmp     #_FMul_ret              ' check for NaN
02328 05b             | 
02328 05b E7 C7 BF 6C |                         xor     flagA, flagB            ' get sign of result
0232c 05c E8 C9 BF 80 |                         add     expA, expB              ' add exponents
02330 05d 00 B2 FF A0 |                         mov     t1, #0                  ' t2 = upper 32 bits of manB
02334 05e 20 B4 FF A0 |                         mov     t2, #32                 ' loop counter for multiply
02338 05f 01 D2 FF 29 |                         shr     manB, #1 wc             ' get initial multiplier bit 
0233c 060             |                                     
0233c 060 E5 B3 B3 81 | :multiply if_c          add     t1, manA wc             ' 32x32 bit multiply
02340 061 01 B2 FF 31 |                         rcr     t1, #1 wc
02344 062 01 D2 FF 31 |                         rcr     manB, #1 wc
02348 063 60 B4 FF E4 |                         djnz    t2, #:multiply
0234c 064             | 
0234c 064 03 B2 FF 2C |                         shl     t1, #3                  ' justify result and exit
02350 065 D9 CB BF A0 |                         mov     manA, t1                        
02354 066 B0 91 FF 5C |                         call    #_Pack 
02358 067             | _FMulI_ret
02358 067 00 00 7C 5C | _FMul_ret               ret
0235c 068             | 
0235c 068             | '------------------------------------------------------------------------------
0235c 068             | ' _FDiv    fnumA = fnumA / fNumB
0235c 068             | ' _FDivI   fnumA = fnumA / {Float immediate}
0235c 068             | ' changes: fnumA, flagA, expA, manA, fnumB, flagB, expB, manB, t1, t2
0235c 068             | '------------------------------------------------------------------------------
0235c 068             | 
0235c 068 7A D4 BC 50 | _FDivI                  movs    :getB, _FDivI_ret       ' get immediate value
02360 069 01 F4 FC 80 |                         add     _FDivI_ret, #1
02364 06a 00 CC BF A0 | :getB                   mov     fnumB, 0
02368 06b             | 
02368 06b 86 23 FF 5C | _FDiv                   call    #_Unpack2               ' unpack two variables
0236c 06c CB C5 BB A0 |           if_c_or_z     mov     fnumA, NaN              ' check for NaN or divide by 0
02370 06d 7A 00 78 5C |           if_c_or_z     jmp     #_FDiv_ret
02374 06e             |         
02374 06e E7 C7 BF 6C |                         xor     flagA, flagB            ' get sign of result
02378 06f E8 C9 BF 84 |                         sub     expA, expB              ' subtract exponents
0237c 070 00 B2 FF A0 |                         mov     t1, #0                  ' clear quotient
02380 071 1E B4 FF A0 |                         mov     t2, #30                 ' loop counter for divide
02384 072             | 
02384 072 01 B2 FF 2C | :divide                 shl     t1, #1                  ' divide the mantissas
02388 073 E9 CB 3F C3 |                         cmps    manA, manB wz,wc
0238c 074 E9 CB AF 84 |           if_z_or_nc    sub     manA, manB
02390 075 01 B2 EF 80 |           if_z_or_nc    add     t1, #1
02394 076 01 CA FF 2C |                         shl     manA, #1
02398 077 72 B4 FF E4 |                         djnz    t2, #:divide
0239c 078             | 
0239c 078 D9 CB BF A0 |                         mov     manA, t1                ' get result and exit
023a0 079 B0 91 FF 5C |                         call    #_Pack                        
023a4 07a             | _FDivI_ret
023a4 07a 00 00 7C 5C | _FDiv_ret               ret
023a8 07b             | 
023a8 07b             | '------------------------------------------------------------------------------
023a8 07b             | ' _FFloat  fnumA = float(fnumA)
023a8 07b             | ' changes: fnumA, flagA, expA, manA
023a8 07b             | '------------------------------------------------------------------------------
023a8 07b             |          
023a8 07b E2 C7 BF A0 | _FFloat                 mov     flagA, fnumA            ' get integer value
023ac 07c 00 C4 FF A0 |                         mov     fnumA, #0               ' set initial result to zero
023b0 07d E3 CB BF AA |                         abs     manA, flagA wz          ' get absolute value of integer
023b4 07e 87 00 68 5C |           if_z          jmp     #_FFloat_ret            ' if zero, exit
023b8 07f 1F C6 FF 28 |                         shr     flagA, #31              ' set sign flag
023bc 080 1F C8 FF A0 |                         mov     expA, #31               ' set initial value for exponent
023c0 081 01 CA FF 2D | :normalize              shl     manA, #1 wc             ' normalize the mantissa 
023c4 082 01 C8 CF 84 |           if_nc         sub     expA, #1                ' adjust exponent
023c8 083 81 00 4C 5C |           if_nc         jmp     #:normalize
023cc 084 01 CA FF 30 |                         rcr     manA, #1                ' justify mantissa
023d0 085 02 CA FF 28 |                         shr     manA, #2
023d4 086 B0 91 FF 5C |                         call    #_Pack                  ' pack and exit
023d8 087 00 00 7C 5C | _FFloat_ret             ret
023dc 088             | 
023dc 088             | '------------------------------------------------------------------------------
023dc 088             | ' _FTrunc  fnumA = fix(fnumA)
023dc 088             | ' _FRound  fnumA = fix(round(fnumA))
023dc 088             | ' changes: fnumA, flagA, expA, manA, t1 
023dc 088             | '------------------------------------------------------------------------------
023dc 088             | 
023dc 088 00 B2 FF A0 | _FTrunc                 mov     t1, #0                  ' set for no rounding
023e0 089 8B 00 7C 5C |                         jmp     #fix
023e4 08a             | 
023e4 08a 01 B2 FF A0 | _FRound                 mov     t1, #1                  ' set for rounding
023e8 08b             | 
023e8 08b 92 5F FF 5C | fix                     call    #_Unpack                ' unpack floating point value
023ec 08c 98 00 70 5C |           if_c          jmp     #_FRound_ret            ' check for NaN
023f0 08d 02 CA FF 2C |                         shl     manA, #2                ' left justify mantissa 
023f4 08e 00 C4 FF A0 |                         mov     fnumA, #0               ' initialize result to zero
023f8 08f E4 C9 BF A4 |                         neg     expA, expA              ' adjust for exponent value
023fc 090 1E C8 FF 82 |                         add     expA, #30 wz
02400 091 20 C8 7F C1 |                         cmps    expA, #32 wc
02404 092 98 00 6C 5C |           if_nc_or_z    jmp     #_FRound_ret
02408 093 E4 CB BF 28 |                         shr     manA, expA
0240c 094             |                                                        
0240c 094 D9 CB BF 80 |                         add     manA, t1                ' round up 1/2 lsb   
02410 095 01 CA FF 28 |                         shr     manA, #1
02414 096             |                         
02414 096 01 C6 7F 62 |                         test    flagA, #signFlag wz     ' check sign and exit
02418 097 E5 C5 BF 9C |                         sumnz   fnumA, manA
0241c 098             | _FTrunc_ret
0241c 098 00 00 7C 5C | _FRound_ret             ret
02420 099             |                                   
02420 099             | '------------------------------------------------------------------------------
02420 099             | ' _FSqr    fnumA = sqrt(fnumA)
02420 099             | ' changes: fnumA, flagA, expA, manA, t1, t2, t3, t4, t5 
02420 099             | '------------------------------------------------------------------------------
02420 099             | 
02420 099 92 5F FF 5C | _FSqr                   call    #_Unpack                 ' unpack floating point value
02424 09a 00 C4 CF A0 |           if_nc         mov     fnumA, #0                ' set initial result to zero
02428 09b B4 00 78 5C |           if_c_or_z     jmp     #_FSqr_ret               ' check for NaN or zero
0242c 09c 01 C6 7F 62 |                         test    flagA, #signFlag wz      ' check for negative
02430 09d CB C5 97 A0 |           if_nz         mov     fnumA, NaN               ' yes, then return NaN                       
02434 09e B4 00 54 5C |           if_nz         jmp     #_FSqr_ret
02438 09f             |           
02438 09f 01 C8 7F 62 |                         test    expA, #1 wz             ' if even exponent, shift mantissa 
0243c 0a0 01 CA EB 28 |           if_z          shr     manA, #1
02440 0a1 01 C8 FF 38 |                         sar     expA, #1                ' get exponent of root
02444 0a2 D1 B3 BF A0 |                         mov     t1, Bit30               ' set root value to $4000_0000                ' 
02448 0a3 1F B4 FF A0 |                         mov     t2, #31                 ' get loop counter
0244c 0a4             | 
0244c 0a4 D9 C5 BF 68 | :sqrt                   or      fnumA, t1               ' blend partial root into result
02450 0a5 20 B6 FF A0 |                         mov     t3, #32                 ' loop counter for multiply
02454 0a6 00 B8 FF A0 |                         mov     t4, #0
02458 0a7 E2 BB BF A0 |                         mov     t5, fnumA
0245c 0a8 01 BA FF 29 |                         shr     t5, #1 wc               ' get initial multiplier bit
02460 0a9             |                         
02460 0a9 E2 B9 B3 81 | :multiply if_c          add     t4, fnumA wc            ' 32x32 bit multiply
02464 0aa 01 B8 FF 31 |                         rcr     t4, #1 wc
02468 0ab 01 BA FF 31 |                         rcr     t5, #1 wc
0246c 0ac A9 B6 FF E4 |                         djnz    t3, #:multiply
02470 0ad             | 
02470 0ad DC CB 3F C1 |                         cmps    manA, t4 wc             ' if too large remove partial root
02474 0ae D9 C5 B3 6C |           if_c          xor     fnumA, t1
02478 0af 01 B2 FF 28 |                         shr     t1, #1                  ' shift partial root
0247c 0b0 A4 B4 FF E4 |                         djnz    t2, #:sqrt              ' continue for all bits
02480 0b1             |                         
02480 0b1 E2 CB BF A0 |                         mov     manA, fnumA             ' store new mantissa value and exit
02484 0b2 01 CA FF 28 |                         shr     manA, #1
02488 0b3 B0 91 FF 5C |                         call    #_Pack
0248c 0b4 00 00 7C 5C | _FSqr_ret               ret
02490 0b5             | 
02490 0b5             | '------------------------------------------------------------------------------
02490 0b5             | ' _FCmp    set Z and C flags for fnumA - fNumB
02490 0b5             | ' _FCmpI   set Z and C flags for fnumA - {Float immediate}
02490 0b5             | ' changes: status, t1
02490 0b5             | '------------------------------------------------------------------------------
02490 0b5             | 
02490 0b5 CA 6E BD 50 | _FCmpI                  movs    :getB, _FCmpI_ret       ' get immediate value
02494 0b6 01 94 FD 80 |                         add     _FCmpI_ret, #1
02498 0b7 00 CC BF A0 | :getB                   mov     fnumB, 0
0249c 0b8             | 
0249c 0b8 E2 B3 BF A0 | _FCmp                   mov     t1, fnumA               ' compare signs
024a0 0b9 E6 B3 BF 6C |                         xor     t1, fnumB
024a4 0ba D2 B3 BF 62 |                         and     t1, Bit31 wz
024a8 0bb C2 00 68 5C |           if_z          jmp     #:cmp1                  ' same, then compare magnitude
024ac 0bc             |           
024ac 0bc E2 B3 BF A0 |                         mov     t1, fnumA               ' check for +0 or -0 
024b0 0bd E6 B3 BF 68 |                         or      t1, fnumB
024b4 0be D2 B3 BF 67 |                         andn    t1, Bit31 wz,wc         
024b8 0bf C7 00 68 5C |           if_z          jmp     #:exit
024bc 0c0             |                     
024bc 0c0 D2 C5 3F 61 |                         test    fnumA, Bit31 wc         ' compare signs
024c0 0c1 C7 00 7C 5C |                         jmp     #:exit
024c4 0c2             | 
024c4 0c2 D2 C5 3F 62 | :cmp1                   test    fnumA, Bit31 wz         ' check signs
024c8 0c3 C6 00 54 5C |           if_nz         jmp     #:cmp2
024cc 0c4 E6 C5 3F 87 |                         cmp     fnumA, fnumB wz,wc
024d0 0c5 C7 00 7C 5C |                         jmp     #:exit
024d4 0c6             | 
024d4 0c6 E2 CD 3F 87 | :cmp2                   cmp     fnumB, fnumA wz,wc      ' reverse test if negative
024d8 0c7             | 
024d8 0c7 01 C2 FF A0 | :exit                   mov     status, #1              ' if fnumA > fnumB, t1 = 1
024dc 0c8 E1 C3 B3 A4 |           if_c          neg     status, status          ' if fnumA < fnumB, t1 = -1
024e0 0c9 00 C2 EB A0 |           if_z          mov     status, #0              ' if fnumA = fnumB, t1 = 0
024e4 0ca             | _FCmpI_ret
024e4 0ca 00 00 7C 5C | _FCmp_ret               ret
024e8 0cb             | 
024e8 0cb             | '------------------------------------------------------------------------------
024e8 0cb             | ' _Sin     fnumA = sin(fnumA)
024e8 0cb             | ' _Cos     fnumA = cos(fnumA)
024e8 0cb             | ' changes: fnumA, flagA, expA, manA, fnumB, flagB, expB, manB
024e8 0cb             | ' changes: t1, t2, t3, t4, t5, t6
024e8 0cb             | '------------------------------------------------------------------------------
024e8 0cb             | 
024e8 0cb 3E AA FC 5C | _Cos                    call    #_FAddI                 ' cos(x) = sin(x + pi/2)
024ec 0cc DB 0F C9 3F |                         long    pi / 2.0
024f0 0cd             | 
024f0 0cd E2 BD BF A0 | _Sin                    mov     t6, fnumA               ' save original angle
024f4 0ce 68 F4 FC 5C |                         call    #_FDivI                 ' reduce angle to 0 to 2pi
024f8 0cf DB 0F C9 40 |                         long    2.0 * pi
024fc 0d0 88 30 FD 5C |                         call    #_FTrunc
02500 0d1 CB C5 3F 86 |                         cmp     fnumA, NaN wz           ' check for NaN
02504 0d2 FC 00 68 5C |           if_z          jmp     #_Sin_ret               
02508 0d3 7B 0E FD 5C |                         call    #_FFloat
0250c 0d4 56 CE FC 5C |                         call    #_FMulI
02510 0d5 DB 0F C9 40 |                         long    2.0 * pi
02514 0d6 E2 CD BF A0 |                         mov     fnumB, fnumA
02518 0d7 DE C5 BF A0 |                         mov     fnumA, t6
0251c 0d8 3C AA FC 5C |                         call    #_FSub
02520 0d9 D2 C5 3F 62 |                         test    fnumA, bit31 wz
02524 0da DD 00 68 5C |           if_z          jmp     #:sin1
02528 0db 3E AA FC 5C |                         call    #_FAddI
0252c 0dc DB 0F C9 40 |                         long    2.0 * pi
02530 0dd             | 
02530 0dd 56 CE FC 5C | :sin1                   call    #_FMulI                 ' convert to 13 bit integer plus fraction
02534 0de 83 F9 A2 44 |                         long    8192.0 / (2.0 * pi)
02538 0df E2 BB BF A0 |                         mov     t5, fnumA               ' get fraction
0253c 0e0 61 D5 FE 5C |                         call    #_Frac
02540 0e1 E2 B9 BF A0 |                         mov     t4, fnumA
02544 0e2 DD C5 BF A0 |                         mov     fnumA, t5               ' get integer
02548 0e3 88 30 FD 5C |                         call    #_FTrunc                        
0254c 0e4             | 
0254c 0e4 D7 C5 3F 61 |                         test    fnumA, Sin_90 wc        ' set C flag for quandrant 2 or 4
02550 0e5 D8 C5 3F 62 |                         test    fnumA, Sin_180 wz       ' set Z flag for quandrant 3 or 4
02554 0e6 E2 C5 BF B0 |                         negc    fnumA, fnumA            ' if quandrant 2 or 4, negate offset
02558 0e7 D6 C5 BF 68 |                         or      fnumA, SineTable        ' blend in sine table address
0255c 0e8 01 C4 FF 2C |                         shl     fnumA, #1               ' get table offset
02560 0e9             | 
02560 0e9 E2 B5 BF 04 |                         rdword  t2, fnumA               ' get first table value
02564 0ea DA B5 BF BC |                         negnz   t2, t2                  ' if quandrant 3 or 4, negate
02568 0eb 02 C4 CF 80 |           if_nc         add     fnumA, #2               ' get second table value  
0256c 0ec 02 C4 F3 84 |           if_c          sub     fnumA, #2
02570 0ed E2 B7 BF 04 |                         rdword  t3, fnumA
02574 0ee DB B7 BF BC |                         negnz   t3, t3                  ' if quandrant 3 or 4, negate
02578 0ef             | 
02578 0ef DA C5 BF A0 |                         mov     fnumA, t2               ' result = float(value1)
0257c 0f0 7B 0E FD 5C |                         call    #_FFloat
02580 0f1 DC CD BF A2 |                         mov     fnumB, t4 wz            ' exit if no fraction
02584 0f2 FA 00 68 5C |           if_z          jmp     #:sin2
02588 0f3             | 
02588 0f3 E2 BB BF A0 |                         mov     t5, fnumA               ' interpolate the fractional value 
0258c 0f4 DB C5 BF A0 |                         mov     fnumA, t3
02590 0f5 DA C5 BF 84 |                         sub     fnumA, t2
02594 0f6 7B 0E FD 5C |                         call    #_FFloat 
02598 0f7 59 CE FC 5C |                         call    #_FMul
0259c 0f8 DD CD BF A0 |                         mov     fnumB, t5
025a0 0f9 41 AA FC 5C |                         call    #_FAdd
025a4 0fa             | 
025a4 0fa 68 F4 FC 5C | :sin2                   call    #_FDivI                 ' set range from -1.0 to 1.0 and exit
025a8 0fb 00 FF 7F 47 |                         long    65535.0
025ac 0fc             | _Cos_ret
025ac 0fc 00 00 7C 5C | _Sin_ret                ret
025b0 0fd             | 
025b0 0fd             | '------------------------------------------------------------------------------
025b0 0fd             | ' _Tan   fnumA = tan(fnumA)
025b0 0fd             | ' changes: fnumA, flagA, expA, manA, fnumB, flagB, expB, manB
025b0 0fd             | ' changes: t1, t2, t3, t4, t5, t6, t7, t8
025b0 0fd             | '------------------------------------------------------------------------------
025b0 0fd             | 
025b0 0fd E2 BF BF A0 | _Tan                    mov     t7, fnumA               ' tan(x) = sin(x) / cos(x)
025b4 0fe CB F8 FD 5C |                         call    #_Cos
025b8 0ff E2 C1 BF A0 |                         mov     t8, fnumA
025bc 100 DF C5 BF A0 |                         mov     fnumA, t7    
025c0 101 CD F8 FD 5C |                         call    #_Sin
025c4 102 E0 CD BF A0 |                         mov     fnumB, t8
025c8 103 6B F4 FC 5C |                         call    #_FDiv
025cc 104 00 00 7C 5C | _Tan_ret                ret
025d0 105             | 
025d0 105             | '------------------------------------------------------------------------------
025d0 105             | ' _Log     fnumA = log (base e) fnumA
025d0 105             | ' _Log10   fnumA = log (base 10) fnumA
025d0 105             | ' _Log2    fnumA = log (base 2) fnumA
025d0 105             | ' changes: fnumA, flagA, expA, manA, fnumB, flagB, expB, manB, t1, t2, t3, t5
025d0 105             | '------------------------------------------------------------------------------
025d0 105             | 
025d0 105 0D 3F FE 5C | _Log                    call    #_Log2                  ' log base e
025d4 106 68 F4 FC 5C |                         call    #_FDivI
025d8 107 3B AA B8 3F |                         long    1.442695041
025dc 108 00 00 7C 5C | _Log_ret                ret
025e0 109             | 
025e0 109 0D 3F FE 5C | _Log10                  call    #_Log2                  ' log base 10
025e4 10a 68 F4 FC 5C |                         call    #_FDivI
025e8 10b 78 9A 54 40 |                         long    3.321928095
025ec 10c 00 00 7C 5C | _Log10_ret              ret
025f0 10d             | 
025f0 10d 92 5F FF 5C | _Log2                   call    #_Unpack                ' unpack variable 
025f4 10e 1E 01 78 5C |           if_z_or_c     jmp     #:exitNaN               ' if NaN or <= 0, return NaN   
025f8 10f 01 C6 7F 62 |                         test    flagA, #SignFlag wz              
025fc 110 1E 01 54 5C |           if_nz         jmp     #:exitNaN
02600 111             |                       
02600 111 E4 BB BF A0 |                         mov     t5, expA                ' save exponent                                                
02604 112 E5 B3 BF A0 |                         mov     t1, manA                ' get first 11 bits of fraction
02608 113 11 B2 FF 28 |                         shr     t1, #17                 ' get table offset
0260c 114 D5 B3 BF 60 |                         and     t1, TableMask
02610 115 D3 B3 BF 80 |                         add     t1, LogTable            ' get table address
02614 116 7E 0B FF 5C |                         call    #float18Bits            ' remainder = lower 18 bits 
02618 117 E2 B5 BF A0 |                         mov     t2, fnumA
0261c 118 6B FB FE 5C |                         call    #loadTable              ' get fraction from log table
02620 119 E2 CD BF A0 |                         mov     fnumB, fnumA
02624 11a DD C5 BF A0 |                         mov     fnumA, t5               ' convert exponent to float         
02628 11b 7B 0E FD 5C |                         call    #_FFloat
0262c 11c 41 AA FC 5C |                         call    #_FAdd                  ' result = exponent + fraction                               
02630 11d 1F 01 7C 5C |                         jmp     #_Log2_ret
02634 11e             | 
02634 11e CB C5 BF A0 | :exitNaN                mov     fnumA, NaN              ' return NaN
02638 11f             | 
02638 11f 00 00 7C 5C | _Log2_ret               ret
0263c 120             | 
0263c 120             | '------------------------------------------------------------------------------
0263c 120             | ' _Exp     fnumA = e ** fnumA
0263c 120             | ' _Exp10   fnumA = 10 ** fnumA
0263c 120             | ' _Exp2    fnumA = 2 ** fnumA
0263c 120             | ' changes: fnumA, flagA, expA, manA, fnumB, flagB, expB, manB
0263c 120             | ' changes: t1, t2, t3, t4, t5
0263c 120             | '------------------------------------------------------------------------------
0263c 120             | 
0263c 120 56 CE FC 5C | _Exp                    call    #_FMulI                 ' e ** fnum
02640 121 3B AA B8 3F |                         long    1.442695041
02644 122 25 01 7C 5C |                         jmp     #_Exp2
02648 123             | 
02648 123 56 CE FC 5C | _Exp10                  call    #_FMulI                 ' 10 ** fnum
0264c 124 78 9A 54 40 |                         long    3.321928095
02650 125             | 
02650 125 92 5F FF 5C | _Exp2                   call    #_Unpack                ' unpack variable                    
02654 126 42 01 70 5C |           if_c          jmp     #_Exp2_ret              ' check for NaN
02658 127 CA C5 AB A0 |           if_z          mov     fnumA, One              ' if 0, return 1.0
0265c 128 42 01 68 5C |           if_z          jmp     #_Exp2_ret
02660 129 E2 BB BF A0 |                         mov     t5, fnumA               ' save sign value
02664 12a 88 30 FD 5C |                         call    #_FTrunc                ' get positive integer
02668 12b E2 B9 BF A8 |                         abs     t4, fnumA
0266c 12c DD C5 BF A0 |                         mov     fnumA, t5
02670 12d 61 D5 FE 5C |                         call    #_Frac                  ' get fraction
02674 12e 92 5F FF 5C |                         call    #_Unpack
02678 12f E4 C9 BF A4 |                         neg     expA, expA              ' get first 11 bits of fraction
0267c 130 E4 CB BF 28 |                         shr     manA, expA
02680 131 E5 B3 BF A0 |                         mov     t1, manA                ' 
02684 132 11 B2 FF 28 |                         shr     t1, #17                 ' get table offset
02688 133 D5 B3 BF 60 |                         and     t1, TableMask
0268c 134 D4 B3 BF 80 |                         add     t1, AlogTable           ' get table address
02690 135 7E 0B FF 5C |                         call    #float18Bits            ' remainder = lower 18 bits 
02694 136 E2 B5 BF A0 |                         mov     t2, fnumA
02698 137 6B FB FE 5C |                         call    #loadTable              ' get fraction from log table                  
0269c 138 3E AA FC 5C |                         call    #_FAddI                 ' add 1.0
026a0 139 00 00 80 3F |                         long    1.0
026a4 13a 92 5F FF 5C |                         call    #_Unpack                ' align fraction
026a8 13b DC C9 BF 80 |                         add     expA, t4                ' add integer to exponent  
026ac 13c B0 91 FF 5C |                         call    #_Pack
026b0 13d             | 
026b0 13d D2 BB 3F 62 |                         test    t5, Bit31 wz            ' check if negative
026b4 13e 42 01 68 5C |           if_z          jmp     #_Exp2_ret
026b8 13f E2 CD BF A0 |                         mov     fnumB, fnumA            ' yes, then invert
026bc 140 CA C5 BF A0 |                         mov     fnumA, One
026c0 141 6B F4 FC 5C |                         call    #_FDiv
026c4 142             | _Exp_ret             
026c4 142             | _Exp10_ret           
026c4 142 00 00 7C 5C | _Exp2_ret               ret
026c8 143             | 
026c8 143             | '------------------------------------------------------------------------------
026c8 143             | ' _Pow     fnumA = fnumA raised to power fnumB
026c8 143             | ' changes: fnumA, flagA, expA, manA, fnumB, flagB, expB, manB
026c8 143             | '          t1, t2, t3, t5, t6, t7
026c8 143             | '------------------------------------------------------------------------------
026c8 143             | 
026c8 143 CB CD 3F 62 | _Pow                    test    fnumB, NaN wz           ' check exponent
026cc 144 CA C5 AB A0 |           if_z          mov     fnumA, One              ' if exponent=0, set base to 1.0
026d0 145             |           
026d0 145 E2 BF BF A1 |                         mov     t7, fnumA wc            ' save sign of result
026d4 146 55 01 4C 5C |           if_nc         jmp     #:pow3                  ' check sign of base
026d8 147             |                         
026d8 147 E6 C5 BF A0 |                         mov     fnumA, fnumB            ' check exponent
026dc 148 92 5F FF 5C |                         call    #_Unpack
026e0 149 DF C5 BF A0 |                         mov     fnumA, t7               ' restore base
026e4 14a 53 01 68 5C |           if_z          jmp     #:pow2                  ' check for exponent = 0
026e8 14b             |           
026e8 14b D2 C9 3F 62 |                         test    expA, Bit31 wz          ' if exponent < 0, return NaN
026ec 14c 51 01 54 5C |           if_nz         jmp     #:pow1
026f0 14d             | 
026f0 14d 17 C8 FF 4C |                         max     expA, #23               ' check if exponent = integer
026f4 14e E4 CB BF 2C |                         shl     manA, expA    
026f8 14f CE CB 3F 62 |                         and     manA, Mask29 wz, nr                         
026fc 150 53 01 68 5C |           if_z          jmp     #:pow2                  ' yes, then check if odd
02700 151             |           
02700 151 CB C5 BF A0 | :pow1                   mov     fnumA, NaN              ' return NaN
02704 152 60 01 7C 5C |                         jmp     #_Pow_ret
02708 153             | 
02708 153 D0 CB 3F 62 | :pow2                   test    manA, Bit29 wz          ' if odd, then negate result
0270c 154 D2 BF AB 64 |           if_z          andn    t7, Bit31
02710 155             | 
02710 155 D2 CD 3F 61 | :pow3                   test    fnumB, Bit31 wc         ' check sign of exponent
02714 156 D2 C5 BF 66 |                         andn    fnumA, Bit31 wz         ' get |fnumA|
02718 157 51 01 60 5C |           if_z_and_c    jmp     #:pow1                  ' if 0^-n, return NaN
0271c 158 60 01 68 5C |           if_z          jmp     #_Pow_ret               ' if 0^+n, return Zero
02720 159             | 
02720 159 E6 BD BF A0 |                         mov     t6, fnumB               ' save power
02724 15a 0D 3F FE 5C |                         call    #_Log2                  ' get log of base
02728 15b DE CD BF A0 |                         mov     fnumB, t6               ' multiply by power
0272c 15c 59 CE FC 5C |                         call    #_FMul
02730 15d 25 85 FE 5C |                         call    #_Exp2                  ' get result      
02734 15e             | 
02734 15e D2 BF 3F 62 |                         test    t7, Bit31 wz            ' check for negative
02738 15f D2 C5 97 6C |           if_nz         xor     fnumA, Bit31
0273c 160 00 00 7C 5C | _Pow_ret                ret
02740 161             | 
02740 161             | '------------------------------------------------------------------------------
02740 161             | ' _Frac fnumA = fractional part of fnumA
02740 161             | ' changes: fnumA, flagA, expA, manA
02740 161             | '------------------------------------------------------------------------------
02740 161             | 
02740 161 92 5F FF 5C | _Frac                   call    #_Unpack                ' get fraction
02744 162 D2 C9 3F 62 |                         test    expA, Bit31 wz          ' check for exp < 0 or NaN
02748 163 68 01 74 5C |           if_c_or_nz    jmp     #:exit
0274c 164 17 C8 FF 4C |                         max     expA, #23               ' remove the integer
02750 165 E4 CB BF 2C |                         shl     manA, expA    
02754 166 CE CB BF 60 |                         and     manA, Mask29
02758 167 00 C8 FF A0 |                         mov     expA, #0                ' return fraction
0275c 168             | 
0275c 168 B0 91 FF 5C | :exit                   call    #_Pack
02760 169 D2 C5 BF 64 |                         andn    fnumA, Bit31
02764 16a 00 00 7C 5C | _Frac_ret               ret
02768 16b             | 
02768 16b             | '------------------------------------------------------------------------------
02768 16b             | ' input:   t1           table address (long)
02768 16b             | '          t2           remainder (float) 
02768 16b             | ' output:  fnumA        interpolated table value (float)
02768 16b             | ' changes: fnumA, flagA, expA, manA, fnumB, t1, t2, t3
02768 16b             | '------------------------------------------------------------------------------
02768 16b             | 
02768 16b D9 B7 BF 04 | loadTable               rdword  t3, t1                  ' t3 = first table value
0276c 16c 00 B4 7F 86 |                         cmp     t2, #0 wz               ' if remainder = 0, skip interpolation
02770 16d 00 B2 EB A0 |           if_z          mov     t1, #0
02774 16e 74 01 68 5C |           if_z          jmp     #:load2
02778 16f             | 
02778 16f 02 B2 FF 80 |                         add     t1, #2                  ' load second table value
0277c 170 D5 B3 3F 62 |                         test    t1, TableMask wz        ' check for end of table
02780 171 CF B3 AB A0 |           if_z          mov     t1, Bit16               ' t1 = second table value
02784 172 D9 B3 97 04 |           if_nz         rdword  t1, t1
02788 173 DB B3 BF 84 |                         sub     t1, t3                  ' t1 = t1 - t3
0278c 174             | 
0278c 174 DB CB BF A0 | :load2                  mov     manA, t3                ' convert t3 to float
02790 175 80 0B FF 5C |                         call    #float16Bits
02794 176 E2 B7 BF A0 |                         mov     t3, fnumA           
02798 177 D9 CB BF A0 |                         mov     manA, t1                ' convert t1 to float
0279c 178 80 0B FF 5C |                         call    #float16Bits
027a0 179 DA CD BF A0 |                         mov     fnumB, t2               ' t1 = t1 * remainder
027a4 17a 59 CE FC 5C |                         call    #_FMul
027a8 17b DB CD BF A0 |                         mov     fnumB, t3               ' result = t1 + t3
027ac 17c 41 AA FC 5C |                         call    #_FAdd
027b0 17d 00 00 7C 5C | loadTable_ret           ret
027b4 17e             | 
027b4 17e 0E CA FF 2C | float18Bits             shl     manA, #14               ' float lower 18 bits
027b8 17f 81 01 7C 5C |                         jmp     #floatBits
027bc 180 10 CA FF 2C | float16Bits             shl     manA, #16               ' float lower 16 bits
027c0 181 03 CA FF 28 | floatBits               shr     manA, #3                ' align to bit 29
027c4 182 00 C6 FF A0 |                         mov     flagA, #0               ' convert table value to float 
027c8 183 00 C8 FF A0 |                         mov     expA, #0
027cc 184 B0 91 FF 5C |                         call    #_Pack                  ' pack and exit
027d0 185             | float18Bits_ret
027d0 185             | float16Bits_ret
027d0 185 00 00 7C 5C | floatBits_ret           ret
027d4 186             | 
027d4 186             | '------------------------------------------------------------------------------
027d4 186             | ' input:   fnumA        32-bit floating point value
027d4 186             | '          fnumB        32-bit floating point value 
027d4 186             | ' output:  flagA        fnumA flag bits (Nan, Infinity, Zero, Sign)
027d4 186             | '          expA         fnumA exponent (no bias)
027d4 186             | '          manA         fnumA mantissa (aligned to bit 29)
027d4 186             | '          flagB        fnumB flag bits (Nan, Infinity, Zero, Sign)
027d4 186             | '          expB         fnumB exponent (no bias)
027d4 186             | '          manB         fnumB mantissa (aligned to bit 29)
027d4 186             | '          C flag       set if fnumA or fnumB is NaN
027d4 186             | '          Z flag       set if fnumB is zero
027d4 186             | ' changes: fnumA, flagA, expA, manA, fnumB, flagB, expB, manB, t1
027d4 186             | '------------------------------------------------------------------------------
027d4 186             | 
027d4 186 E2 B3 BF A0 | _Unpack2                mov     t1, fnumA               ' save A
027d8 187 E6 C5 BF A0 |                         mov     fnumA, fnumB            ' unpack B to A
027dc 188 92 5F FF 5C |                         call    #_Unpack
027e0 189 91 01 70 5C |           if_c          jmp     #_Unpack2_ret           ' check for NaN
027e4 18a             | 
027e4 18a E2 CD BF A0 |                         mov     fnumB, fnumA            ' save B variables
027e8 18b E3 CF BF A0 |                         mov     flagB, flagA
027ec 18c E4 D1 BF A0 |                         mov     expB, expA
027f0 18d E5 D3 BF A0 |                         mov     manB, manA
027f4 18e             | 
027f4 18e D9 C5 BF A0 |                         mov     fnumA, t1               ' unpack A
027f8 18f 92 5F FF 5C |                         call    #_Unpack
027fc 190 00 D2 7F 86 |                         cmp     manB, #0 wz             ' set Z flag                      
02800 191 00 00 7C 5C | _Unpack2_ret            ret
02804 192             | 
02804 192             | '------------------------------------------------------------------------------
02804 192             | ' input:   fnumA        32-bit floating point value 
02804 192             | ' output:  flagA        fnumA flag bits (Nan, Infinity, Zero, Sign)
02804 192             | '          expA         fnumA exponent (no bias)
02804 192             | '          manA         fnumA mantissa (aligned to bit 29)
02804 192             | '          C flag       set if fnumA is NaN
02804 192             | '          Z flag       set if fnumA is zero
02804 192             | ' changes: fnumA, flagA, expA, manA
02804 192             | '------------------------------------------------------------------------------
02804 192             | 
02804 192 E2 C7 BF A0 | _Unpack                 mov     flagA, fnumA            ' get sign
02808 193 1F C6 FF 28 |                         shr     flagA, #31
0280c 194 E2 CB BF A0 |                         mov     manA, fnumA             ' get mantissa
02810 195 CD CB BF 60 |                         and     manA, Mask23
02814 196 E2 C9 BF A0 |                         mov     expA, fnumA             ' get exponent
02818 197 01 C8 FF 2C |                         shl     expA, #1
0281c 198 18 C8 FF 2A |                         shr     expA, #24 wz
02820 199 9F 01 68 5C |           if_z          jmp     #:zeroSubnormal         ' check for zero or subnormal
02824 19a FF C8 7F 86 |                         cmp     expA, #255 wz           ' check if finite
02828 19b AA 01 54 5C |           if_nz         jmp     #:finite
0282c 19c CB C5 BF A0 |                         mov     fnumA, NaN              ' no, then return NaN
02830 19d 08 C6 FF A0 |                         mov     flagA, #NaNFlag
02834 19e AD 01 7C 5C |                         jmp     #:exit2        
02838 19f             | 
02838 19f E4 CB 3F 6A | :zeroSubnormal          or      manA, expA wz,nr        ' check for zero
0283c 1a0 A4 01 54 5C |           if_nz         jmp     #:subnorm
02840 1a1 02 C6 FF 68 |                         or      flagA, #ZeroFlag        ' yes, then set zero flag
02844 1a2 96 C8 FF A4 |                         neg     expA, #150              ' set exponent and exit
02848 1a3 AD 01 7C 5C |                         jmp     #:exit2
0284c 1a4             |                                  
0284c 1a4 07 CA FF 2C | :subnorm                shl     manA, #7                ' fix justification for subnormals  
02850 1a5 D0 CB 3F 62 | :subnorm2               test    manA, Bit29 wz
02854 1a6 AC 01 54 5C |           if_nz         jmp     #:exit1
02858 1a7 01 CA FF 2C |                         shl     manA, #1
0285c 1a8 01 C8 FF 84 |                         sub     expA, #1
02860 1a9 A5 01 7C 5C |                         jmp     #:subnorm2
02864 1aa             | 
02864 1aa 06 CA FF 2C | :finite                 shl     manA, #6                ' justify mantissa to bit 29
02868 1ab D0 CB BF 68 |                         or      manA, Bit29             ' add leading one bit
0286c 1ac             |                         
0286c 1ac 7F C8 FF 84 | :exit1                  sub     expA, #127              ' remove bias from exponent
02870 1ad 08 C6 7F 61 | :exit2                  test    flagA, #NaNFlag wc      ' set C flag
02874 1ae 00 CA 7F 86 |                         cmp     manA, #0 wz             ' set Z flag
02878 1af 00 00 7C 5C | _Unpack_ret             ret       
0287c 1b0             | 
0287c 1b0             | '------------------------------------------------------------------------------
0287c 1b0             | ' input:   flagA        fnumA flag bits (Nan, Infinity, Zero, Sign)
0287c 1b0             | '          expA         fnumA exponent (no bias)
0287c 1b0             | '          manA         fnumA mantissa (aligned to bit 29)
0287c 1b0             | ' output:  fnumA        32-bit floating point value
0287c 1b0             | ' changes: fnumA, flagA, expA, manA 
0287c 1b0             | '------------------------------------------------------------------------------
0287c 1b0             | 
0287c 1b0 00 CA 7F 86 | _Pack                   cmp     manA, #0 wz             ' check for zero                                        
02880 1b1 00 C8 EB A0 |           if_z          mov     expA, #0
02884 1b2 C3 01 68 5C |           if_z          jmp     #:exit1
02888 1b3             | 
02888 1b3 01 CA FF 2D | :normalize              shl     manA, #1 wc             ' normalize the mantissa 
0288c 1b4 01 C8 CF 84 |           if_nc         sub     expA, #1                ' adjust exponent
02890 1b5 B3 01 4C 5C |           if_nc         jmp     #:normalize
02894 1b6             |                       
02894 1b6 02 C8 FF 80 |                         add     expA, #2                ' adjust exponent
02898 1b7 00 CB FF 81 |                         add     manA, #$100 wc          ' round up by 1/2 lsb
0289c 1b8 01 C8 F3 80 |           if_c          add     expA, #1
028a0 1b9             | 
028a0 1b9 7F C8 FF 80 |                         add     expA, #127              ' add bias to exponent
028a4 1ba CC C9 BF 40 |                         mins    expA, Minus23
028a8 1bb FF C8 FF 44 |                         maxs    expA, #255
028ac 1bc             |  
028ac 1bc 01 C8 7F C1 |                         cmps    expA, #1 wc             ' check for subnormals
028b0 1bd C3 01 4C 5C |           if_nc         jmp     #:exit1
028b4 1be             | 
028b4 1be 01 CA FF 68 | :subnormal              or      manA, #1                ' adjust mantissa
028b8 1bf 01 CA FF 20 |                         ror     manA, #1
028bc 1c0             | 
028bc 1c0 E4 C9 BF A4 |                         neg     expA, expA
028c0 1c1 E4 CB BF 28 |                         shr     manA, expA
028c4 1c2 00 C8 FF A0 |                         mov     expA, #0                ' biased exponent = 0
028c8 1c3             | 
028c8 1c3 E5 C5 BF A0 | :exit1                  mov     fnumA, manA             ' bits 22:0 mantissa
028cc 1c4 09 C4 FF 28 |                         shr     fnumA, #9
028d0 1c5 E4 C5 BF 58 |                         movi    fnumA, expA             ' bits 23:30 exponent
028d4 1c6 1F C6 FF 2C |                         shl     flagA, #31
028d8 1c7 E3 C5 BF 68 |                         or      fnumA, flagA            ' bit 31 sign            
028dc 1c8 00 00 7C 5C | _Pack_ret               ret
028e0 1c9             |         
028e0 1c9             | '-------------------- constant values -----------------------------------------
028e0 1c9             | 
028e0 1c9 00 00 00 00 | Zero                    long    0                       ' constants
028e4 1ca 00 00 80 3F | One                     long    $3F80_0000
028e8 1cb FF FF FF 7F | NaN                     long    $7FFF_FFFF
028ec 1cc E9 FF FF FF | Minus23                 long    -23
028f0 1cd FF FF 7F 00 | Mask23                  long    $007F_FFFF
028f4 1ce FF FF FF 1F | Mask29                  long    $1FFF_FFFF
028f8 1cf 00 00 01 00 | Bit16                   long    $0001_0000
028fc 1d0 00 00 00 20 | Bit29                   long    $2000_0000
02900 1d1 00 00 00 40 | Bit30                   long    $4000_0000
02904 1d2 00 00 00 80 | Bit31                   long    $8000_0000
02908 1d3 00 C0 00 00 | LogTable                long    $C000
0290c 1d4 00 D0 00 00 | ALogTable               long    $D000
02910 1d5 FE 0F 00 00 | TableMask               long    $0FFE
02914 1d6 00 70 00 00 | SineTable               long    $E000 >> 1
02918 1d7 00 08 00 00 | Sin_90                  long    $0800
0291c 1d8 00 10 00 00 | Sin_180                 long    $1000
02920 1d9             | 
02920 1d9             | '-------------------- local variables -----------------------------------------
02920 1d9             | 
02920 1d9             | t1                      res     1                       ' temporary values
02920 1d9             | t1                      res     1                       ' temporary values
02920 1d9             | t2                      res     1
02920 1d9             | t2                      res     1
02920 1d9             | t3                      res     1
02920 1d9             | t3                      res     1
02920 1d9             | t4                      res     1
02920 1d9             | t4                      res     1
02920 1d9             | t5                      res     1
02920 1d9             | t5                      res     1
02920 1d9             | t6                      res     1
02920 1d9             | t6                      res     1
02920 1d9             | t7                      res     1
02920 1d9             | t7                      res     1
02920 1d9             | t8                      res     1
02920 1d9             | t8                      res     1
02920 1d9             | 
02920 1d9             | status                  res     1                       ' last compare status
02920 1d9             | status                  res     1                       ' last compare status
02920 1d9             | 
02920 1d9             | fnumA                   res     1                       ' floating point A value
02920 1d9             | fnumA                   res     1                       ' floating point A value
02920 1d9             | flagA                   res     1
02920 1d9             | flagA                   res     1
02920 1d9             | expA                    res     1
02920 1d9             | expA                    res     1
02920 1d9             | manA                    res     1
02920 1d9             | manA                    res     1
02920 1d9             | 
02920 1d9             | fnumB                   res     1                       ' floating point B value
02920 1d9             | fnumB                   res     1                       ' floating point B value
02920 1d9             | flagB                   res     1
02920 1d9             | flagB                   res     1
02920 1d9             | expB                    res     1
02920 1d9             | expB                    res     1
02920 1d9             | manB                    res     1
02920 1d9             | manB                    res     1
02920 1d9 00 00 00 00 
      ...             
02a5c 228 00 00 00 00 
02a60 229 00 00 00 00 | 	long	0[81]
02a64 22a             | stackspace
02a64 22a 00 00 00 00 | 	long	0[1]
02a68 0d1             | 	org	COG_BSS_START
02a68 0d1             | _var01
02a68 0d1             | 	res	1
02a68 0d2             | _var02
02a68 0d2             | 	res	1
02a68 0d3             | _var03
02a68 0d3             | 	res	1
02a68 0d4             | _var04
02a68 0d4             | 	res	1
02a68 0d5             | _var05
02a68 0d5             | 	res	1
02a68 0d6             | arg01
02a68 0d6             | 	res	1
02a68 0d7             | arg02
02a68 0d7             | 	res	1
02a68 0d8             | arg03
02a68 0d8             | 	res	1
02a68 0d9             | arg04
02a68 0d9             | 	res	1
02a68 0da             | arg05
02a68 0da             | 	res	1
02a68 0db             | local01
02a68 0db             | 	res	1
02a68 0dc             | local02
02a68 0dc             | 	res	1
02a68 0dd             | local03
02a68 0dd             | 	res	1
02a68 0de             | local04
02a68 0de             | 	res	1
02a68 0df             | local05
02a68 0df             | 	res	1
02a68 0e0             | local06
02a68 0e0             | 	res	1
02a68 0e1             | local07
02a68 0e1             | 	res	1
02a68 0e2             | local08
02a68 0e2             | 	res	1
02a68 0e3             | local09
02a68 0e3             | 	res	1
02a68 0e4             | muldiva_
02a68 0e4             | 	res	1
02a68 0e5             | muldivb_
02a68 0e5             | 	res	1
02a68 0e6             | LMM_RETREG
02a68 0e6             | 	res	1
02a68 0e7             | LMM_FCACHE_START
02a68 0e7             | 	res	97
02a68 148             | LMM_FCACHE_END
02a68 148             | 	fit	496
02a68 148             | 
