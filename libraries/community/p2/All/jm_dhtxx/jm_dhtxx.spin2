'' =================================================================================================''''   File....... jm_dhtxx.spin2''   Purpose.... Interface for DHT11/DHT22 Temperature/Humidity Sensors''   Author..... Jon "JonnyMac" McPhalen''               Copyright (c) 2021 Jon McPhalen''               -- see below for terms of use''   E-mail..... jon.mcphalen@gmail.com''   Started....''   Updated.... 14 JAN 2021'''' ================================================================================================={  Wakes and reads data from DHT11/DHT22 or compatible temp/humidity sensor.  Resources:  -- http://robocraft.ru/files/datasheet/DHT11.pdf  -- https://cdn-shop.adafruit.com/datasheets/Digital+humidity+and+temperature+sensor+AM2302.pdf}con { fixed io pins }  RX1    = 63  { I }                                            ' programming / debug  TX1    = 62  { O }  SF_CS  = 61  { O }                                            ' serial flash  SF_SCK = 60  { O }  SF_SDO = 59  { O }  SF_SDI = 58  { I }con  #true,  ON, OFF  #false, NO, YES  CM2302 = 22                                                   ' device types  DHT22  = 22  DHT11  = 11  #0, PU_EXT, PU_INT                                            ' pull-up modes  #0, ERR_NONE, ERR_BUS, ERR_RESP, ERR_PKT, ERR_CRC             ' error conditionsvar { globals }  long  dio                                                     ' sensor pin  long  smode                                                   ' sensor mode  long  us1tix                                                  ' ticks in 1us  long  last                                                    ' last access time  long  refresh                                                 ' min time between access  long  errorlevel                                              ' 0 on good read  long  tempc                                                   ' latest readings  long  humidity  byte  dht[5]                                                  ' packet bytespub null()'' This is not a top-level objectpub start(pin, type, pullup)'' Assign pin to DHTxx sensor'' -- type is 11 or 22'' -- pullup is 0 for external, 1 for internal  dio := pin                                                    ' save IO pin  if (type == 22)                                               ' get type    smode := 22                                                 ' set mode for conversions    refresh := 2000                                             ' set minimum refresh timing  else    smode := 11    refresh := 1000  pinclear(dio)                                                 ' remove old settings  if (pullup)                                                   ' set pull-up mode    wrpin(dio, P_HIGH_1K5)  else    wrpin(dio, P_HIGH_FLOAT)  pinh(dio)                                                     ' enable pull-up  us1tix := (clkfreq / 1_000_000)                               ' clock ticks in 1us  last := getms() - refreshpub read_tempc() : result'' Returns current temperature in 0.1C units  if ((getms()-last) >= refresh)                                ' okay to read sensor    new_read()  return tempcpub read_tempf() : result'' Returns current temperature in 0.1F units  return read_tempc() * 9 / 5 + 32_0pub read_humidity() : result'' Returns relative humidity in 0.1% units  if ((getms()-last) >= refresh)    new_read()  return humiditypub error_level() : result                                      ' for debugging  return errorlevelpub p_packet() : result                                         ' for debugging  return @dhtpri new_read() : result'' Wake and read sensor  last := getms()                                               ' mark last access  longfill(@tempc, 0, 2)                                        ' clear results  if (smode == 22)    errorlevel := read_dht( 2_000, @dht)                        ' get new data  else    errorlevel := read_dht(19_000, @dht)  if (errorlevel <> ERR_NONE)    return' DHT22 mode  if (smode == 22)                                              ' convert packet bytes    humidity := (dht[0] << 8) | dht[1]    tempc    := ((dht[2] & $7F) << 8) | dht[3]    if (dht[2].[7])                                             ' check negative temp bit      tempc := 0 - tempc    return' DHT11 mode' -- convert to 0.1 units to match DHT22  humidity := dht[0] * 10  tempc    := dht[2] * 10pri read_dht(wt, p_dat) : result | p, tix1, timeout, t0, t1, idx1, idx2, b, crc'' Wake DHTxx device and read packet'' -- wt is wake time in microseconds'' -- p_dat is pointer to 5-byte data array  p, tix1 := dio, us1tix                                        ' copy global vars  org.setup          rep       #2, #5                 wrbyte   #0, p_dat                 add      p_dat, #1                sub       p_dat, #5                             ' restore packet pointer                qmul      tix1, #90                             ' calcuate timeout ticks                getqx     timeout.wake           drvl      p                                     ' stimulous pulse                rep       #1, wt                 waitx    tix1                drvh      p.check_bus      rep       #1, #5                                ' let bus rise                 waitx    tix1                testp     p                             wc      ' verify high    if_nc       jmp       #.bus_error.check_resp0    rep       #1, #40                               ' let device respond                 waitx    tix1                testp     p                             wc      ' verify low    if_c        jmp       #.resp_error.check_resp1    call      #.get_pulse                           ' get response pulse                tjz       t1, #.resp_error                      ' abort on timeout                qdiv      t1, tix1                              ' convert to usecs                getqx     t1                cmp       t1, #65                       wcz     ' check range    if_b        jmp       #.resp_error                cmp       t1, #95                       wcz    if_a        jmp       #.resp_error.get_packet     mov       idx1, #5                              ' get 5 bytes                mov       crc, #0                               ' clear crc.get_byte       mov       idx2, #8                              ' 8 bits per byte.get_bit        call      #.get_pulse                           ' meaure pulse                tjz       t1, #.pkt_error                       ' check for timeout                qdiv      t1, tix1                              ' convert pulse to usecs                getqx     t1                cmp       t1, #50                       wcz     ' convert to bit                shl       b, #1                                 ' prep for new bit    if_a        or        b, #$01                               ' add to byte                djnz      idx2, #.get_bit                       ' next bit                and       b, #$FF                               ' clean up                wrbyte    b, p_dat                              ' write to hub                add       crc, b                                ' update crc                add       p_dat, #1                             ' advance hub pointer                djnz      idx1, #.get_byte                      ' next byte.check_crc      sub       crc, b                                ' remove last byte                and       crc, #$FF                             ' isolate low byte                cmp       crc, b                        wcz     ' check crc    if_e        mov       result, #ERR_NONE                     ' good crc    if_ne       mov       result, #ERR_CRC                      ' bad crc                jmp       #.done' allow up to 90us for rising edge' allow up to 90us for next falling edge.get_pulse      getct     t0                                    ' mark start of low period.p0_loop        getct     t1                                    ' mark time now                subs      t1, t0                                ' t1 is elapsed ticks                cmps      t1, timeout                   wcz     ' check for timeout    if_a        mov       t1, #0                                ' set to error    if_a        ret                testp     p                             wc      ' no timeout, pin high?    if_nc       jmp       #.p0_loop                             ' if not, try again.get_pulse1     getct     t0.p1_loop        getct     t1                subs      t1, t0                cmps      t1, timeout                   wcz    if_a        mov       t1, #0    if_a        ret                testp     p                             wc    if_c        jmp       #.p1_loop                ret' error conditions.pkt_error      mov       result, #ERR_PKT                jmp       #.done.resp_error     neg       result, #ERR_RESP                jmp       #.done.bus_error      neg       result, #ERR_BUS.done           ret  endcon { license }{{  Terms of Use: MIT License  Permission is hereby granted, free of charge, to any person obtaining a copy of this  software and associated documentation files (the "Software"), to deal in the Software  without restriction, including without limitation the rights to use, copy, modify,  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to the following  conditions:  The above copyright notice and this permission notice shall be included in all copies  or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}